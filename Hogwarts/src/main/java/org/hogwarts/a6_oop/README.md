# Принципы ООП

**ООП** — это подход к программированию, в котором программа организована вокруг объектов и их взаимодействия.
Объекты представляют собой конкретную реализацию какого-то класса. Например, есть человек — это класс.
То есть это определенный биологический вид. А есть вы — конкретный человек. В парадигме ООП вы — объект,
а человек — класс. Мы с вами — объекты класса Человек.

## Принципы ООП:

1. [x] **Абстракция**: Позволяет скрыть детали реализации и сосредоточиться на сущностях, которые имеют значение для
   конкретных нужд.
2. [x] **Инкапсуляция**: Сокрытие внутренних данных и реализации за публичными интерфейсами классов.
3. [x] **Наследование**: Создание новых классов на основе существующих, с возможностью повторного использования кода и
   расширения функциональности.
4. [x] **Полиморфизм**: Возможность объектов с разной реализацией вести себя одинаково через общие интерфейсы.

## Абстракция

**Абстракция** — это процесс выделения важных характеристик объекта и игнорирования ненужных деталей.
Она позволяет рассматривать объекты, обобщая их общие черты и характеристики.
Этот принцип позволяет программистам сосредотачиваться на существенных аспектах задачи.
В Java абстракция реализуется через **абстрактные классы** и **интерфейсы**.
Они служат в качестве шаблонов для создания конкретных классов, которые наследуют **абстрактные черты** и *
*функциональность**.

### Польза абстракции:

- **Упрощение**: Абстракция позволяет упростить понимание системы, сосредотачиваясь на ключевых аспектах.
- **Модульность**: Абстракция позволяет разделить функциональность на модули, что упрощает сопровождение и расширение
  кода.
- **Изоляция**: Абстракция изолирует детали реализации, что позволяет менять внутреннюю структуру без воздействия на
  внешний код.

Хорошим примером абстракции является анкетирование. Например, если вы хотите подать заявку на участие в Турнире
Трех Волшебников, вам необходимо в анкете указать, например, свой возраст, имя, владение метлой, знание особых
заклинаний.
При этом вам не нужно указывать цвет своих волос или номер телефона вашего дедушки — для этого конкретного события
такие детали считаются несущественными. Поэтому вы абстрагируетесь от них и используете только те, которые помогут
вам пройти отборочный тур.

## Инкапсуляция

**Инкапсуляция** представляет собой механизм, который позволяет упаковать данные и методы, работающие с этими данными,
в одну единицу, называемую классом. Она ограничивает доступ к внутренним деталям класса, что обеспечивает безопасность
и защиту данных. Так, например, когда мы составляем анкету для Турнира, мы можем всю нашу информацию сложить в одном
месте.
Например, создать класс Questionnaire, который будет содержать в себе поля, которые нужно будет заполнить каждому
студенту.

```  
public class Questionnaire {

    private String name;
		private int age;
		private boolean uniqueSpells;
		private boolean broomSkilled;
}
```

В этом примере мы инкапсулировали все необходимые данные в одном месте так, чтобы их не пришлось искать — они уже
все собраны вместе.

Представьте себе ситуацию: вам поручили пройти по всем студентам в школе и собрать с них ответы на анкету.
То есть каждый студент расскажет вам 4 пункта о себе. Скорее всего, вы захотите эту информацию как-то упорядочить и
собрать все ответы одного студента в одном месте. Просто берете листок с анкетой, даете студенту, он заполняет, и у
вас есть полная собранная информация в одном месте! Еще тысяча таких анкет, и дело сделано…

### Преимущества инкапсуляции:

1. [x] **Защита данных**: Инкапсуляция позволяет предотвратить случайное или нежелательное изменение данных извне.
2. [x] **Модульность**: Классы с инкапсулированными данными можно использовать как модули, что упрощает сопровождение и
   расширение кода.
3. [x] **Изоляция изменений**: Изменение внутренних деталей класса не влияет на другие части программы, использующие
   этот класс.

### Принципы инкапсуляции:

1. [x] **Принцип минимального доступа (Principle of Least Access):** Класс должен предоставлять только те методы и
   данные,
   которые необходимы для выполнения задачи. То есть не содержать ничего лишнего и несущественного.
2. [x] **Скрытие деталей реализации (Implementation Hiding):** Внутренние детали класса должны быть скрыты от внешнего
   мира.
   Ни один из тысячи студентов не должен иметь возможности изменить в вашей анкете поле age на количество пальцев на
   руках, например.
   Вы — владелец этого шаблона анкеты, вы не можете позволить кому-то ее изменить без вашего ведома.

Инкапсуляция в Java реализуется с помощью модификаторов доступа **(public, private, protected, default)** и специальных
методов — геттеров и сеттеров. Про модификаторы поговорим в следующих уроках, а сейчас обратим внимание на методы get и
set.

**Геттеры** (get-методы) предоставляют доступ к значениям полей класса, а сеттеры (set-методы) позволяют изменять
значения полей.

``` 
public class Questionnaire {

    private String name;
		private int age;
		private boolean uniqueSpells;
		private boolean broomSkilled;
		
		public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}
```

Так, любой пользователь может вызвать метод getName у объекта класса Questionnaire, чтобы получить имя студента,
полнившего анкету. А чтобы заполнить имя в своей анкете, нужно вызвать метод setName.

## Наследование

**Наследование** — это принцип объектно-ориентированного программирования (ООП), который позволяет создавать новые
классы
на основе существующих, наследуя их поля и методы. Наследование позволяет создавать новые классы на основе уже
существующих, перенимая их характеристики и функциональность.

### Преимущества наследования:

1. [x] **Повторное использование кода:** Код из родительского класса может быть повторно использован в дочерних классах.
2. [x] **Расширение функциональности:** Дочерние классы могут добавлять новые поля и методы, расширяя функциональность
   родительского класса, но не изменяя его.
3. [x] **Иерархия классов:** Наследование позволяет создавать иерархии классов, что улучшает организацию кода.

Класс, от которого наследуется другой класс, называется **родительским (предком)**, а класс, наследующий его, называется
**дочерним (потомком)**. Так, например, наш класс Questionnaire может стать классом-родителем для разных видов анкет:

``` 
class Questionnaire {
    String name;
}

class TriwizardTournamentQuestionnaire extends Questionnaire {
    int age;
		boolean uniqueSpells;
		boolean broomSkilled;
}
```

- **Во-первых,** обращаем внимание на слово extends. Оно используется для того, чтобы заставить один класс наследоваться
  от другого. То есть здесь мы говорим, что класс TriwizardTournamentQuestionnaire расширяет (extends) класс
  Questionnaire.
- **Далее**, замечаем, что сейчас в классе Questionnaire есть только одно поле — String name. Почему? Потому что обычно,
  какую бы анкету мы не заполняли, нам нужно там указать свое имя. То есть это поле будет общим для заполнения вообще
  любой анкеты. Поэтому мы выносим его в класс-родитель, чтобы не писать в классах наследниках постоянно одну и ту же
  строчку private String name;.
- **Далее** уже в классе-наследнике, который представляет собой анкету на Турнир Трех Волшебников
  TriwizardTournamentQuestionnaire, описываем все нужные именно в этом классе поля. Так, мы можем создать сколько угодно
  наследников класса Questionnaire и в эти классы добавлять какие-угодно поля и методы.

### Использование ключевого слова super.

Ключевое слово **super** используется для обращения к методам и полям родительского класса.
Так, чтобы получить доступ к полю name из класса Questionnaire, необходимо использовать конструкцию **super.name**.
Через super можно обратиться к полю. А если в классе Questionnaire есть геттер, то для обращения к полю можно
использовать его: super.getName() — в обоих случаях мы получим имя.

```  
class Questionnaire {
    String name;
}

class TriwizardTournamentQuestionnaire extends Questionnaire {
    int age;
		boolean uniqueSpells;
		boolean broomSkilled;

		public void getInfo() {
        System.out.println("Имя: " + super.name + ", Возраст: " + age);
    }
}
```

## Переопределение методов. OVERRIDING

Дочерние классы могут переопределять методы родительских классов для адаптации к своим потребностям.
Допустим, в нашем классе Questionnaire есть метод getInfo, который служит для получения информации о человеке,
который заполнил анкету:

``` 
class Questionnaire {
    String name;

		public String getName() {
        return name;
    }

		public void getInfo() {
        System.out.println("Имя: " + name);
    }
}
```

Тогда мы сможем переопределить, то есть задать другую логику этому методу, в классе-наследнике:

``` 
class TriwizardTournamentQuestionnaire extends Questionnaire {
    private int age;
		private boolean uniqueSpells;
		private boolean broomSkilled;

        @Override
		public void getInfo() {
        System.out.println("Имя: " + super.getName() + ", Возраст: " + age);
    }
}
```

### Иерархии наследования.

У одного класса-родителя может быть сколько угодно дочерних классов. Например, помимо дочернего класса
TriwizardTournamentQuestionnaire мы можем создать еще одного наследника класса Questionnaire. Например,
HospitalQuestionnaire:

``` 
class HospitalQuestionnaire extends Questionnaire {
    private int age;
		private String complaints;
}
```

Это вообще другой класс, предназначенный для записи к врачу. Но он все еще наследуется от нашего класс-анкеты, потому
что существует для той же цели — помочь пользователю собрать всю нужную информацию в одном месте.

💡 **У любого класса может быть сколько угодно наследников, но при этом один класс может наследоваться только от одного
другого класса.**

## Полиморфизм

**Полиморфизм** — это принцип объектно-ориентированного программирования (ООП), который позволяет объектам с разной
реализацией вести себя одинаково через общие интерфейсы. Полиморфизм позволяет использовать объекты разных типов через
общие атрибуты, вне зависимости от их конкретной реализации. Страшно, да.

**Преимущества полиморфизма:**

1. [x] Гибкость кода: Код может работать с разными объектами, поддерживая общие интерфейсы.
2. [x] Легкость расширения: Добавление новых реализаций не требует изменения существующего кода.
3. [x] Поддержание кода: Изменения в реализации могут быть сделаны только в соответствующих классах.

Полиморфизм тесно связан с этими понятиями, поэтому будем подходить к нему постепенно.