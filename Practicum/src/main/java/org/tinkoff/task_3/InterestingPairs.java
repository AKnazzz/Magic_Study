package org.tinkoff.task_3;


import java.util.Scanner;

/*
  Виктория рассматривает занимательную квадратную двумерную матрицу, которая состоит только из натуральных чисел.
  Она то и дело суммирует числа в столбцах и строках.
  Виктория называет пару строки-столбца интересными, если сумма чисел в строке отличается от суммы чисел в столбце не более чем на величину числа на пересечении этих строки и столбца.

  Найдите количество интересных пар строка-столбец во всей матрице.

  Формат входных данных:
  В первой строке дано число n (1 <= n <= 1000) — размер квадратной матрицы.
  В последующих n строках задано описание матрицы по n целых неотрицательных чисел в каждой.
  Элементы матрицы a (i,j) лежат в диапазоне ( 0 <= a (i,j) <= 100000).

  Формат выходных данных: Выведите количество искомых пар.

  Пример 1
  Ввод:
  2
  1 9
  0 5
  Вывод: 1

  Пример 2
  Ввод:
  4
  1 1 4 3
  1 2 9 2
  1 4 2 1
  5 2 1 3
  Вывод: 10

  Пример 3
  Ввод:
  4
  0 0 0 0
  0 1 1 0
  0 1 1 0
  1 1 1 0
  Вывод: 7
 */

/*
Для решения задачи о нахождении интересных пар "строка-столбец" в квадратной матрице, мы можем воспользоваться следующим подходом:

1. Считать входные данные: Прочитать размер матрицы n и саму матрицу.
2. Вычислить суммы строк и столбцов: Создать два массива для хранения сумм строк и сумм столбцов.
3. Проверить условия интересности: Для каждой пары (строка, столбец) проверить, удовлетворяет ли она условию интересности, и подсчитать такие пары.

### Алгоритм

1. Прочитать размер матрицы n.
2. Считать элементы матрицы и одновременно вычислить суммы строк и столбцов.
3. Для каждой пары (i, j) проверить, выполняется ли:
    {сумма_столбца}[i] - {сумма_строки}[j] <= число на пересечении[i][j]
4. Подсчитать количество таких пар.

 */


public class InterestingPairs {
    public static void main(String[] args) {

        Scanner scanner = new Scanner(System.in);

        // Чтение размера матрицы
        int n;

        do {
            System.out.println("Введите размер квадратной матрицы от 1 до 1000 :");
            n = scanner.nextInt();

            if (n < 1 || n > 1000) {
                System.out.println("Ошибка: размер матрицы должен быть в диапазоне от 1 до 1000.");
            }
        } while (n < 1 || n > 1000);


        // Инициализация матрицы и массивов для сумм
        int[][] matrix = new int[n][n];
        long[] sumRow = new long[n];
        long[] sumCol = new long[n];

        // Чтение матрицы и вычисление сумм строк и столбцов
        System.out.println("Введите значения элементов матрицы :");
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                matrix[i][j] = scanner.nextInt();

                // Проверка на диапазон элемента
                if (matrix[i][j] < 0 || matrix[i][j] > 100000) {
                    System.out.println("Ошибка: элемент матрицы должен быть в диапазоне от 0 до 100000.");
                    j--; // Уменьшаем j, чтобы повторно ввести элемент
                } else {
                    sumRow[i] += matrix[i][j];
                    sumCol[j] += matrix[i][j];
                }
            }
        }

        // Подсчет интересных пар
        int interestingPairsCount = 0;

        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (Math.abs(sumRow[i] - sumCol[j]) <= matrix[i][j]) {
                    interestingPairsCount++;
                }
            }
        }

        // Вывод результата
        System.out.println("Кол-во интересных пар: " + interestingPairsCount);
        scanner.close();
    }
}

/* ### Объяснение кода:

1. Считывание данных: Мы используем Scanner для считывания размера матрицы и ее элементов.
2. Суммы строк и столбцов: Два массива sumRow и sumCol используются для хранения сумм строк и столбцов соответственно.
3. Проверка условия: Два вложенных цикла проходят по всем парам (i, j), проверяя условие интересности и увеличивая счетчик interestingPairsCount, если условие выполняется.
4. Вывод результата: В конце выводится общее количество интересных пар.

### Сложность алгоритма:
- Временная сложность**: \\( O(n^2) \\), так как мы проходим по всем элементам матрицы дважды (один раз для вычисления сумм и один раз для проверки условий).
- Пространственная сложность**: \\( O(n) \\) для хранения сумм строк и столбцов.

 */