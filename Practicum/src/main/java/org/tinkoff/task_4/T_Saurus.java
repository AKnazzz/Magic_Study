package org.tinkoff.task_4;

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;

/**
 * Система исполнения «T-Saurus» разработана для параллельного выполнения процессов.
 * Инженеры самой высокой квалификации разработали её таким образом, что одновременно может исполняться бесконечное количество процессов,
 * т. е. вместимость исполнителя не ограничена. Причем, после запуска процесса он успешно завершается ровно через одну секунду.
 *
 * Несмотря на невероятную эффективность параллелизации, некоторые процессы не могут быть начаты, пока другие не завершат своё исполнение (так часто бывает в реальных системах, когда один процесс использует результаты работы другого и соответственно не может быть запущен с ним параллельно).
 * При этом один процесс может ожидать завершения нескольких процессов.
 *
 * Все процессы в системе пронумерованы от 1 до n.
 * Для каждого процесса известно, результаты работы каких процессов ему потребуются для исполнения.
 * Ваша задача состоит в том, чтобы определить, за какое минимальное количество секунд могут быть исполнены все процессы.
 *
 * Гарантируется, что отсутствуют циклические зависимости, и процессы завершатся за конечное время.
 * Также гарантируется, что процесс с номером 1 всегда будет завершаться последним.
 *
 * Формат входных данных
 *
 * В первой строке дано число n(1 <= n <= 100000) — количество процессов.
 * Далее дано n строк.
 * В i-й строке первым числом идёт ai — количество необходимых i-му процессу процессов для старта.
 * Далее идет ai чисел через пробел — их номера.
 *
 *
 * Формат выходных данных
 * В единственной строке выведите количество секунд — минимальное время, за которое все процессы смогут завершиться.
 */

/*
Для решения задачи о параллельном выполнении процессов с зависимостями можно использовать алгоритм топологической сортировки.
Мы будем представлять процессы и их зависимости в виде направленного графа, где каждая вершина соответствует процессу, а направленное ребро указывает на зависимость.

### Подход к решению:

1. Строим граф зависимостей: Для каждого процесса создаем список его зависимостей.
2. Считаем входные степени: Для каждого процесса подсчитываем количество процессов, от которых он зависит.
3. Используем очередь: Сначала добавляем в очередь все процессы без зависимостей (т.е. те, которые могут быть выполнены сразу).
4. Топологическая сортировка: Извлекаем процессы из очереди, уменьшаем счетчик зависимостей для зависимых процессов и добавляем их в очередь, когда все их зависимости завершены.
5. Считаем время: Для каждого процесса фиксируем время его завершения и обновляем максимальное время для его зависимых процессов.

 */


public class T_Saurus {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // Чтение количества процессов
        int n = scanner.nextInt();

        // Список зависимостей и входных степеней
        List<List<Integer>> dependencies = new ArrayList<>();
        int[] inDegree = new int[n + 1];

        // Инициализация списка зависимостей
        for (int i = 0; i <= n; i++) {
            dependencies.add(new ArrayList<>());
        }

        // Чтение зависимостей
        for (int i = 1; i <= n; i++) {
            int ai = scanner.nextInt();
            for (int j = 0; j < ai; j++) {
                int dependency = scanner.nextInt();
                dependencies.get(dependency).add(i); // dependency -> i
                inDegree[i]++; // Увеличиваем входную степень для i
            }
        }

        // Очередь для процессов без зависимостей
        Queue<Integer> queue = new LinkedList<>();
        int[] finishTime = new int[n + 1];

        // Добавляем процессы без зависимостей в очередь
        for (int i = 1; i <= n; i++) {
            if (inDegree[i] == 0) {
                queue.offer(i);
                finishTime[i] = 1; // Если процесс можно начать сразу, он завершится через 1 секунду
            }
        }

        // Процесс топологической сортировки
        while (!queue.isEmpty()) {
            int currentProcess = queue.poll();

            for (int dependent : dependencies.get(currentProcess)) {
                inDegree[dependent]--; // Уменьшаем входную степень для зависимого процесса

                // Обновляем время завершения зависимого процесса
                finishTime[dependent] = Math.max(finishTime[dependent], finishTime[currentProcess] + 1);

                // Если все зависимости завершены, добавляем в очередь
                if (inDegree[dependent] == 0) {
                    queue.offer(dependent);
                }
            }
        }

        // Вывод максимального времени завершения всех процессов
        System.out.println(finishTime[1]); // Процесс 1 завершается последним
        scanner.close();
    }
}

//### Объяснение кода:
//
//1. Структуры данных:
//   - dependencies: список, где для каждого процесса хранятся его зависимые процессы.
//   - inDegree: массив, который хранит количество зависимостей для каждого процесса.
//   - finishTime: массив, который хранит время завершения каждого процесса.
//
//2. **Чтение входных данных**:
//   - Мы считываем количество процессов и их зависимости, заполняя соответствующие структуры данных.
//
//3. **Инициализация очереди**:
//   - Все процессы без зависимостей добавляются в очередь, и им присваивается время завершения 1.
//
//4. **Топологическая сортировка**:
//   - Извлекаем процесс из очереди, уменьшаем входные степени его зависимых процессов и обновляем их время завершения.
// 5. **Вывод результата**:
//   - В конце мы выводим время завершения процесса с номером 1, так как он завершается последним.
//
//### Сложность алгоритма:
//- **Временная сложность**: \\( O(n + m) \\), где \\( n \\) — количество процессов, \\( m \\) — количество зависимостей.
//- **Пространственная сложность**: \\( O(n + m) \\) для хранения графа и входных степеней.