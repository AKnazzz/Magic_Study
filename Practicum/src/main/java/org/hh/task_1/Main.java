package org.hh.task_1;

/**
 * После очередного завершённого проекта программист Пётр решил переехать в деревню и заняться сельским хозяйством.
 * Мелочиться он не стал, поэтому помимо домика в деревне сразу приобрёл несколько идущих подряд параллельных участков поля, расположенных вдоль прямой дороги.
 * Участки были разделены заборами, при этом все заборы начинались от той самой дороги, но заканчивались на разном удалении от неё не доходя до противоположной границы участка.
 * Петру нужно объединить эти участки.
 * Но так как Пётр перфекционист, он непременно хочет, чтобы получившийся объединённый участок:
 * 1. был прямоугольным;
 * 2. был ограничен дорогой и двумя уже имеющимися заборами (забор необязательно использовать целиком, а вот удлинять забор нельзя);
 * 3. имел наибольшую возможную площадь.
 * Как и положено разработчику Пётр получает 300к/наносек, поэтому его совсем не беспокоит тот факт, что часть территории окажется неиспользованной.
 * Пётр хочет отдохнуть, поэтому он попросил вас помочь с нахождением площади такого участка.
 * Помогите Петру и найдите два забора, которые вместе с дорогой образуют максимальный по площади прямоугольный участок, и выведите эту площадь.
 * <p>
 * Ширина всех участков одинакова и равна 1.
 * Входные данные (поступают в стандартный поток ввода)
 * На вход вашей программе подаётся одна строка, содержащая массив целых чисел length, где length[i] - длина i-ого забора.
 * Иными словами i-ый элемент массива задаёт забор в виде отрезка от (i, 0) до (i, length[i]), где 0 - это дорога.
 * <p>
 * Причём 0≤length[i]≤10 000, а количество заборов n удовлетворяет условию 2≤n≤100 000.
 * Все входные данные наших тестов всегда соблюдают указанные параметры, дополнительные проверки не требуются.
 * <p>
 * Выходные данные (ожидаются в стандартном потоке вывода)
 * Одно целое число, максимальная площадь образованного участка.
 * ====================
 * Пример 1
 * Ввод:
 * 2 4 3 2 1 4 1
 * Вывод:
 * 16
 * В первом примере участок наибольшей площади образуется между двумя заборами длины 4.
 * ====================
 * Пример 2
 * Ввод:
 * 1 2
 * Вывод:
 * 1
 * В данном примере второй забор используется не на всю длину, т.к. нас интересуют только прямоугольные участки.
 * ====================
 * Примечания по оформлению решения
 * Возможно использование только стандартных библиотек языков, установка и использование дополнительных библиотек невозможны.
 * При отправке решений на Java необходимо назвать исполняемый класс Main. В решении не нужно указывать пакет.
 */

import java.util.Scanner;

public class Main {
    public static void main(String[] args) {

        Scanner in = new Scanner(System.in);
        String line = in.nextLine();
        String[] splitLines = line.split(" ");

        int n = splitLines.length;

        int[] lengths = new int[n];

        for (int i = 0; i < n; i++) {
            lengths[i] = Integer.parseInt(splitLines[i]); // заполним массив длинами заборов
        }

        int left = 0;
        int right = n - 1;
        int maxArea = 0; // счетчик площади

        while (left < right) {

            int height = Math.min(lengths[left], lengths[right]);  // Мин высота между двумя заборами
            int width = right - left; // ширина между заборами
            int area = height * width; // Площадь

            maxArea = Math.max(maxArea, area);

            if (lengths[left] < lengths[right]) { // двигаем указатель с меньшей высотой
                left++;
            } else {
                right--;
            }
        }
        in.close();
        System.out.println(maxArea);
    }
}

//▎Пояснение к коду:
//- Мы считываем входные данные и преобразуем их в массив целых чисел.
//- Затем, с помощью двух указателей, мы вычисляем максимальную площадь возможного прямоугольника.
//- В конце выводим максимальную площадь.
//
//▎Сложность:
//- Временная сложность: O(n), где n — количество заборов. Мы проходим по массиву только один раз.
//- Пространственная сложность: O(1), так как мы используем только фиксированное количество дополнительных переменных.
//
//Таким образом, данный алгоритм эффективно решает задачу поиска максимальной площади прямоугольного участка, ограниченного двумя заборами и дорогой.