package org.hh.task_2;

/**
 * Отдыхая в деревне Пётр мысленно вернулся в детство и вспомнил одну из своих любимых компьютерных игр.
 * В мире этой игры произошёл катаклизм, разорвавший его на множество островов летающих в космическом пространстве.
 * Со временем острова расположились в пространстве ровным рядом, один за другим.
 * <p>
 * После катаклизма, осталось всего два способа путешествовать по миру:
 * 1. Магические паромы, перемещающиеся между соседними островами (естественно, паром может двигаться в обе стороны),
 * таким образом с острова, который стоит на i-ом месте в космическом ряду, можно попасть на i-1 и i+1 острова;
 * 2. Порталы, через которые можно телепортироваться между островами независимо от расстояния,
 * но только если до катаклизма эти острова составляли один материк (любопытно, что материки в этом мире имели не названия, а номера).
 * <p>
 * Петру стало интересно, за какое минимальное количество перемещений можно добраться от первого острова до последнего.
 * Помогите ему это выяснить (сам он всё ещё отдыхает).
 * <p>
 * Входные данные (поступают в стандартный поток ввода)
 * На вход вашей программе подаётся одна строка, содержащая массив целых чисел islands,
 * где islands[i] - это числовое обозначение материка, к которому когда-то относился i-ый остров.
 * Элементы в массиве расположены в том же порядке, что и острова в космическом пространстве.
 * <p>
 * Причём -100 000 000≤islands[i]≤100 000 000, а количество островов n удовлетворяет условию 1≤n≤50 000.
 * Все входные данные наших тестов всегда соблюдают указанные параметры, дополнительные проверки не требуются.
 * <p>
 * Выходные данные (ожидаются в стандартном потоке вывода)
 * Одно целое число, минимальное число шагов от первого острова до последнего.
 * <p>
 * =======================
 * <p>
 * Пример 1
 * Ввод:
 * 3 5 2 2 5
 * Вывод:
 * 2
 * <p>
 * Простой пример для ознакомления с входными и выходными данными.
 * На вход подаются 5 островов.
 * С первого острова можно попасть только на второй с помощью парома.
 * Порталы использовать не получится, т.к. нет других островов носящих тот же номер материка.
 * Со второго можно добраться на пароме обратно на первый или вперёд на третий.
 * А также можно переместиться через портал на пятый (ведь они имеют один и тот же номер).
 * Таким образом мы можем переместиться от первой ячейки до последней за два шага.
 * <p>
 * =======================
 * <p>
 * Пример 2
 * Ввод:
 * 11 -86 -86 201 11 86 86 86 3 201
 * Вывод:
 * 3
 * <p>
 * Во втором примере потребуется уже 3 шага: Перемещение через портал до 5го острова, шаг назад до 4го (с помощью парома)
 * и, наконец, скачок через портал до последнего.
 * <p>
 * =======================
 * <p>
 * Пример 3
 * Ввод:
 * 3 2 5 2 5 2 5 3
 * Вывод:
 * 1
 * Тривиальный пример: требуется всего одно перемещение через портал от первого острова до последнего.
 */


import java.util.*;

public class Main {
    public static void main(String[] args) {

        try (Scanner in = new Scanner(System.in)) {
            String line = in.nextLine();
            String[] parts = line.split(" ");
            int n = parts.length;
            int[] islands = new int[n];

            for (int i = 0; i < n; i++) {
                islands[i] = Integer.parseInt(parts[i]);
            }
            in.close();
            System.out.println(minStepsToReachLastIsland(islands));

        } catch (NumberFormatException e) {
            System.out.println("Ошибка: введено не число. Пожалуйста, введите корректные числа.");
        } catch (Exception e) {
            System.out.println("Произошла ошибка: " + e.getMessage());
        }
    }

    private static int minStepsToReachLastIsland(int[] islands) {
        int n = islands.length;

        if (n == 1) { // Если у нас только один остров
            return 0;
        }

        // Создаем список для хранения индексов островов по материкам
        Map<Integer, List<Integer>> continentMap = new HashMap<>();
        for (int i = 0; i < n; i++) {
            continentMap.computeIfAbsent(islands[i], k -> new ArrayList<>()).add(i);
        }

        // BFS алгоритм поиска в ширину
        Queue<Integer> queue = new LinkedList<>();
        boolean[] visited = new boolean[n]; // массив флагов посещения острова
        queue.add(0); // Начинаем с первого острова
        visited[0] = true;
        int steps = 0; // кол-во шагов

        while (!queue.isEmpty()) {
            int size = queue.size(); // кол-во островов которые можно посетить за один шаг
            for (int i = 0; i < size; i++) {
                int current = queue.poll();

                //  если наш остров — это последний (индекс n - 1), возвращаем количество шагов, которое было сделано.
                if (current == n - 1) {
                    return steps;
                }

                // Проверяем соседние острова
                if (current > 0 && !visited[current - 1]) { // если есть левый сосед и он не был посещён, добавляем его в очередь и помечаем как посещённый.
                    visited[current - 1] = true;
                    queue.add(current - 1);
                }
                if (current < n - 1 && !visited[current + 1]) { // аналогично правый
                    visited[current + 1] = true;
                    queue.add(current + 1);
                }

                // Проверяем порталы
                List<Integer> sameContinent = continentMap.get(islands[current]);
                for (int index : sameContinent) {
                    if (!visited[index]) {
                        visited[index] = true;
                        queue.add(index);
                    }
                }
                // После использования портала, очищаем список, чтобы не использовать его повторно
                sameContinent.clear();
            }
            steps++;
        }
        return -1; // означает, что путь не был найден (хотя по условию задачи это не должно произойти)
    }
}

//Пояснение к коду:
//- Мы считываем входные данные и создаем массив islands.
//- Затем создаем хеш-таблицу continentMap, которая хранит индексы островов по материкам.
//- Используем BFS для поиска минимального количества шагов от первого до последнего острова.
//- В процессе BFS проверяем соседние острова и используем порталы для перехода на другие острова с тем же номером материка.
//- Как только достигаем последнего острова, возвращаем количество шагов.
//
//▎Сложность:
//- Временная сложность: O(n), так как каждый узел посещается не более одного раза.
//- Пространственная сложность: O(n) для хранения информации о материках и очереди BFS.
//Этот алгоритм эффективно решает задачу с учетом всех условий.
