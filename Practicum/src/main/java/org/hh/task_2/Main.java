package org.hh.task_2;

/**
 * Отдыхая в деревне Пётр мысленно вернулся в детство и вспомнил одну из своих любимых компьютерных игр. В мире этой игры произошёл катаклизм, разорвавший его на множество островов летающих в космическом пространстве. Со временем острова расположились в пространстве ровным рядом, один за другим.
 * После катаклизма, осталось всего два способа путешествовать по миру:
 * 1. магические паромы, перемещающиеся между соседними островами (естественно, паром может двигаться в обе стороны), таким образом с острова, который стоит на i-ом месте в космическом ряду, можно попасть на i-1 и i+1 острова;
 * 2. порталы, через которые можно телепортироваться между островами независимо от расстояния, но только если до катаклизма эти острова составляли один материк (любопытно, что материки в этом мире имели не названия, а номера).
 * Петру стало интересно, за какое минимальное количество перемещений можно добраться от первого острова до последнего. Помогите ему это выяснить (сам он всё ещё отдыхает).
 *
 * Входные данные (поступают в стандартный поток ввода)
 * На вход вашей программе подаётся одна строка, содержащая массив целых чисел islands, где islands[i] - это числовое обозначение материка, к которому когда-то относился i-ый остров. Элементы в массиве расположены в том же порядке, что и острова в космическом пространстве.
 * Причём -100 000 000≤islands[i]≤100 000 000, а количество островов n удовлетворяет условию 1≤n≤50 000.
 * Все входные данные наших тестов всегда соблюдают указанные параметры, дополнительные проверки не требуются.
 *
 * Выходные данные (ожидаются в стандартном потоке вывода)
 * Одно целое число, минимальное число шагов от первого острова до последнего.
 *
 *
 * Пример 1
 * Ввод:
 *
 * 3 5 2 2 5
 * Вывод:
 *
 * 2
 * Простой пример для ознакомления с входными и выходными данными.
 *
 * На вход подаются 5 островов.
 *
 * С первого острова можно попасть только на второй с помощью парома. Порталы использовать не получится, т.к. нет других островов носящих тот же номер материка.
 *
 * Со второго можно добраться на пароме обратно на первый или вперёд на третий. А также можно переместиться через портал на пятый (ведь они имеют один и тот же номер).
 *
 * Таким образом мы можем переместиться от первой ячейки до последней за два шага.
 *
 *
 * Пример 2
 * Ввод:
 *
 * 11 -86 -86 201 11 86 86 86 3 201
 * Вывод:
 *
 * 3
 * Во втором примере потребуется уже 3 шага: Перемещение через портал до 5го острова, шаг назад до 4го (с помощью парома) и, наконец, скачок через портал до последнего.
 *
 *
 * Пример 3
 * Ввод:
 *
 * 3 2 5 2 5 2 5 3
 * Вывод:
 *
 * 1
 * Тривиальный пример: требуется всего одно перемещение через портал от первого острова до последнего.
 */


import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        String line = in.nextLine();
        String[] parts = line.split(" ");
        int n = parts.length;
        int[] islands = new int[n];

        for (int i = 0; i < n; i++) {
            islands[i] = Integer.parseInt(parts[i]);
        }

        System.out.println(minStepsToReachLastIsland(islands));
    }

    private static int minStepsToReachLastIsland(int[] islands) {
        int n = islands.length;
        if (n == 1) return 0; // Если только один остров

        // Создаем список для хранения индексов островов по материкам
        Map<Integer, List<Integer>> continentMap = new HashMap<>();
        for (int i = 0; i < n; i++) {
            continentMap.computeIfAbsent(islands[i], k -> new ArrayList<>()).add(i);
        }

        // BFS
        Queue<Integer> queue = new LinkedList<>();
        boolean[] visited = new boolean[n];
        queue.add(0); // Начинаем с первого острова
        visited[0] = true;
        int steps = 0;

        while (!queue.isEmpty()) {
            int size = queue.size();
            for (int i = 0; i < size; i++) {
                int current = queue.poll();

                // Если достигли последнего острова
                if (current == n - 1) {
                    return steps;
                }

                // Проверяем соседние острова
                if (current > 0 && !visited[current - 1]) {
                    visited[current - 1] = true;
                    queue.add(current - 1);
                }
                if (current < n - 1 && !visited[current + 1]) {
                    visited[current + 1] = true;
                    queue.add(current + 1);
                }

                // Проверяем порталы
                List<Integer> sameContinent = continentMap.get(islands[current]);
                for (int index : sameContinent) {
                    if (!visited[index]) {
                        visited[index] = true;
                        queue.add(index);
                    }
                }
                // После использования портала, очищаем список, чтобы не использовать его повторно
                sameContinent.clear();
            }
            steps++;
        }

        return -1; // Если не удалось добраться до последнего острова (что не должно случиться)
    }
}

//Пояснение к коду:
//- Мы считываем входные данные и создаем массив islands.
//- Затем создаем хеш-таблицу continentMap, которая хранит индексы островов по материкам.
//- Используем BFS для поиска минимального количества шагов от первого до последнего острова.
//- В процессе BFS проверяем соседние острова и используем порталы для перехода на другие острова с тем же номером материка.
//- Как только достигаем последнего острова, возвращаем количество шагов.
//
//▎Сложность:
//- Временная сложность: O(n), так как каждый узел посещается не более одного раза.
//- Пространственная сложность: O(n) для хранения информации о материках и очереди BFS.
//Этот алгоритм эффективно решает задачу с учетом всех условий.
