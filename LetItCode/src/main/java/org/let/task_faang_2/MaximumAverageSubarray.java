package org.let.task_faang_2;

/**
 * Вторая задача — Максимальное среднее значение
 * <p>
 * Дан целочисленный массив nums, состоящий из n элементов, и целое число k.
 * Найдите непрерывный подмассив длиной k, имеющий максимальное среднее значение, и верните это значение.
 * Подмассив — это последовательность чисел без изменения порядка или пропуска элементов исходного массива.
 */


public class MaximumAverageSubarray {

    public double findMaxAverage(int[] nums, int k) {
        // Инициализация суммы первых k элементов
        double maxSum = 0;
        for (int i = 0; i < k; i++) {
            maxSum += nums[i];
        }

        // Текущая сумма равна максимальной сумме
        double currentSum = maxSum;

        // Сдвигаем окно по массиву
        for (int i = k; i < nums.length; i++) {
            // Обновляем текущую сумму: вычитаем старый элемент и добавляем новый
            currentSum += nums[i] - nums[i - k];
            // Обновляем максимальную сумму, если текущая больше
            maxSum = Math.max(maxSum, currentSum);
        }

        // Возвращаем максимальное среднее значение
        return maxSum / k;
    }

    public static void main(String[] args) {
        MaximumAverageSubarray solution = new MaximumAverageSubarray();

        int[] nums = {1, 12, -5, -6, 50, 3};
        int k = 4;

        double result = solution.findMaxAverage(nums, k);
        System.out.println("Максимальное среднее значение: " + result);
    }
}

/*
### Объяснение кода:
1. **Метод findMaxAverage**:
   - Сначала вычисляется сумма первых k элементов массива и сохраняется как maxSum.
   - Затем начинается цикл с индекса k до конца массива. Для каждого нового элемента:
     - Обновляется текущая сумма currentSum, добавляя новый элемент и вычитая элемент, который выходит из подмассива.
     - Если текущая сумма больше, чем maxSum, то обновляем maxSum.
   - В конце возвращается максимальное среднее значение, деля maxSum на k.

2. **Метод main**: Пример использования метода с заданным массивом и значением k, а также вывод результата.

Этот алгоритм работает за линейное время O(n), что делает его эффективным для решения задачи.
 */