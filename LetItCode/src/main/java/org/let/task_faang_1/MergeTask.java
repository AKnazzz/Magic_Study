package org.let.task_faang_1;


import java.util.Arrays;

/**
 * Задача — Объединяем массивы
 * <p>
 * Даны 2 целочисленных массива nums1 и nums2, они отсортированы в неубывающем порядке.
 * И 2 числа m и n, которые представляют количество элементов массивов nums1 и nums2 соответственно.
 * <p>
 * Объедините nums1 и nums2 в один массив, элементы которого отсортированы в неубывающем порядке.
 * <p>
 * Конечный отсортированный массив не должен быть возвращен функцией, а вместо этого должен храниться внутри массива nums1.
 * В связи с этим, nums1 имеет длину m + n, где первые m элементов обозначают элементы, которые должны быть объединены,
 * а последние n элементов имеют значение 0 и должны игнорироваться.
 */
public class MergeTask {
    public static void main(String[] args) {


        int[] a = new int[]{1, 2, 3, 0, 0, 0};
        int[] b = new int[]{2, 5, 6};
        int a1 = 3;
        int b2 = 3;

        /*
        int[] a = new int[]{1};
        int[] b = new int[]{};
        int a1 = 1;
        int b2 = 0;

        int[] a = new int[]{0};
        int[] b = new int[]{1};
        int a1 = 0;
        int b2 = 1;

         */

        System.out.println(Arrays.toString(a));
        merge(a, a1, b, b2);
        System.out.println(Arrays.toString(a));


    }
/*
    Для решения задачи нам потребуется 3 указателя.
    Первый будет указывать на конец списка элементов nums1 (m-1),
    второй на конец списка nums2 (n-1),
    а третий на конец списка nums1 с учетом нулей (m+n-1).
    Пока не дойдем до начала списка будем сравнивать элементы на первом и втором указателе и записывать больший элемент на третий указатель.

    Оценка сложности:
    Time complexity:  Время выполнения будет зависеть от длин массивов, т.к. мы перебираем все элементы массива nums1, включая нули и его размер равен n+m
    Space complexity: O(1). Не используются никакие дополнительные структуры данных, которые зависят от размера массивов.

*/


    public static void merge(int[] nums1, int m, int[] nums2, int n) {
        int pointer = m + n - 1; // указывает на последний индекс массива nums1, который будет заполняться. Изначально это m + n - 1, т.е. последний индекс в nums1.
        int pointerNum1 = m - 1;
        int pointerNum2 = n - 1;

        while (pointer >= 0) {
            if (pointerNum2 < 0) { // Если все элементы из nums2 уже были добавлены цикл прерывается, так как оставшиеся элементы из nums1 уже на месте.
                break;
            }

            if (pointerNum1 >= 0 && nums1[pointerNum1] > nums2[pointerNum2]) { //  Если есть еще элементы в обоих массивах (pointerNum1 >= 0), то сравниваются текущие элементы:
                nums1[pointer] = nums1[pointerNum1];
                pointerNum1--;
            } else {
                nums1[pointer] = nums2[pointerNum2];
                pointerNum2--;
            }
            pointer--;
        }

    }
}

