Наталья, привет! Меня зовут Андрей, я твой код-ревьюер. Поздравляю с написанием работы!
Работа хорошая, но есть несколько замечаний и рекомендаций по улучшению кода:
я рассмотрел два приложенных файла - каждый из них решает часть поставленной задачи:
в первом файле выводится строчка с информацией об имени и возрасте друга,
во втором считывается возраст друга и выводится в консоль.
Попробуй объединить эти два варианта - считать с командной строки и возраст, и имя друга.
А после вывести через System.out.println () согласно форме из задания.
Если возникнут трудности попробуй еще раз посмотреть материалы из урока.
У тебя всё получится, жду следующую итерацию.

======================================================================================================

Наталья, привет! Меня зовут Андрей, я посмотрел твою домашнюю работу. Понимание кода может занять время и требует практики.
Я согласен с тобой, что в видео не всегда удается охватить все моменты.
StringBuilder - это класс в Java, который используется для создания и изменения строк.
Он позволяет создавать строку, добавлять к ней символы и удалять их. StringBuilder эффективнее работает с памятью,
чем обычные строки (String), поэтому он часто используется в Java для работы со строками. В данном случае,
строка result создается с помощью StringBuilder, чтобы в нее можно было добавлять символы в цикле.
Тут можно посмотреть подробнее (https://javarush.com/groups/posts/2351-znakomstvo-so-string-stringbuffer-i-stringbuilder-v-java)
Твоё решение первой задачи является корректным и эффективным - код понятно написан и легко читается, ты отлично используешь материалы пройденные на уроке!
Но надо кое-что исправить - на трочках 13 и 19 у тебя лишник фигурные скобки - их надо удалить.
Подумай как можно решить данную задачу с использованием класса StringBuilder (внимательно почитай про методы данного класса).
Также жду твоё решение по второй задаче. Если возникли трудности с понимание условий задачи или у тебя есть какие-то конкретные вопросы по коду,
я могу помочь тебе разобраться в них.
Программирование может быть сложным и иногда требует времени и усилий, чтобы понять его полностью.
Важно продолжать учиться и задавать вопросы, если что-то не понятно. Я готов помочь тебе, так что не стесняйся обращаться за помощью и продолжай практиковаться!

======================================================================================================

Наталья, отличная работа!
Ваше решение полностью соответствует требованиями и выполняет задание корректно.
Мне нравится, что вы использовали цикл for и условия if / else if / else для решения задачи.
Продолжайте в том же духе! Если у вас возникнут какие-либо вопросы или трудности, не стесняйтесь обращаться за помощью
к команде поддержки - это можно сделать через ТГ чат или с помощью кнопки “задать вопрос” на самой платформе.
Удачи в дальнейшем обучении!

======================================================================================================

Отличная работа, Наталья! Поздравляю тебя с тем, что ты успешно справилась с написанием домашней работы.
Твой код хорошо структурирован и понятно написан, что делает его легко читаемым и понятным для других разработчиков.
Однако, у меня есть несколько некритичных замечаний, которые могут помочь тебе улучшить свой код.
Во-первых, в классе AuthorizationFilter рекомендуется добавить обработку случая, когда сессия не существует, например,
перенаправление на страницу логина.
Во-вторых, по сущности Transaction - у тебя отличное решение и оно правильно используется, но обычно для сущнотей
под доходы и расходы испльзуют правтику высталения флага (например true = доход, false = расход).
В-терьих в классах периодически указано ServletException, которое не будет выброшено - рекомендую удалить в тех случаях где это явно не требуется.

В целом, твоя работа заслуживает похвалы. Продолжай в том же духе и удачи в дальнейшем изучении Java!

======================================================================================================

Наталья, привет!
Спасибо за отправку домашней работы. Однако, я заметил, что файл, который вы прислали, пустой (в части выполнения домашней работы).
Возможно, произошла ошибка при отправке или вы перепутали файлы. Если у вас возникли какие-то трудности с выполнением задания,
не стесняйтесь обращаться за помощью к команде поддержки - это моно сделать через ТГ чат или с помощью кнопки “задать вопрос” на самой платформе.
Напомню что в классе ContactDao необходимо было реализовать написанные методы.

Дополнительно советую изучить материалы по теме
https://javarush.com/groups/posts/2172-jdbc-ili-s-chego-vsje-nachinaetsja
или
https://habr.com/ru/articles/326614/
Если возникнут трудности попробуй еще раз посмотреть материалы из урока (см аналогичный класс AccountDao).
У тебя всё получится, жду следующую итерацию.

======================================================================================================

Отличная работа, Андрей!
Я посмотрел твою работу и поздравляю тебя с тем, что ты успешно справился с написанием домашней работы.
Твой код хорошо структурирован и понятно написан, что делает его легко читаемым и понятным для других разработчиков.
Однако, у меня есть несколько некритичных замечаний, которые могут помочь тебе улучшить свой код в будущем:

1. Имена переменных должны быть написаны в camelCase стиле, то есть первое слово в нижнем регистре,а каждое последующее слово начинается с заглавной буквы. Например, вместо "HomeWorkOne" лучше использовать "HomeworkOne".
2. Хорошей практикой считается объявлять все переменные в начале метода или класса (Scanner), чтобы было проще отслеживать их использование и избежать ошибок.
3. В строке вывода "Моему другу с именем" лучше добавить пробел перед словом " лет", чтобы было читаемее. Также по условию задачи в выводе указаны скобки "<" и ">" - их надо добавить в вывод.
4. Пустые строки в коде также могут быть полезны для улучшения его читаемости. Они могут использоваться для разделения логических блоков кода, чтобы сделать его более структурированным и понятным.

В целом, твоя работа заслуживает похвалы. Продолжай в том же духе и удачи в дальнейшем изучении Java!

======================================================================================================

Отличная работа, Павел!
Я рад сообщить, что твоё задание выполнено отлично и полностью соответствует требованиям.
Ты продемонстрировал хорошее понимание темы и отлично справился с заданием.
Желаю удачи в дальнейшем обучении!

P.S. Для улучшения читаемости кода я советовал бы использовать вместо тернарного оператора для проверки на отрицательное число, использовать метод Math.abs(), который вернет абсолютное значение числа.

======================================================================================================

Привет, Мария!

Я хотел бы похвалить тебя за твою работу и код!
Твой код компилируется и легко читается, а также хорошо оформлен.
Ты проделала хорошую работу, и я уверен, что ты можешь достичь еще больших результатов.
Однако, в тестах в классе main не выводятся имена 3-х самых успешных студентов в порядке убывания среднего балла (с твоими тестовыми данные должно вывестись [Tom, Alex, Jerry]).
Это было хорошо рассмотрено на уроке в воркшопе, и это важная часть задания. Подумай как это можно доработать?

Не расстраивайся! Я уверен, что у тебя все получится. Продолжай работать над своим проектом и жду следующую итерацию от тебя.

Удачи!

======================================================================================================

Евгений, привет!
Спасибо за отправку домашней работы!
Код выглядит почти правильным, но есть несколько небольших моментов, которые нужно исправить:
1. Удалить неиспользуемый import (строка 1);
2. Нужно объединить все условия в один блок if-else-if, чтобы избежать повторных проверок;
3. Вместо System.out.println нужно использовать System.out.print, чтобы все числа и слова выводились в одну строку (тогда вывод будет как в условиях задачи 0 1 2 fizz 4 buzz fizz 7 8 fizz buzz 11 fizz 13 14 fizzbuzz);
4. Нужно добавить проверку на деление на оба числа (3 и 5) и вывод fizzbuzz в этом случае (т.к. это требование условий задачи).

Продолжайте в том же духе! Я уверен, что у тебя все получится. Продолжай работать над своим проектом и жду следующую итерацию от тебя.
Удачи в дальнейшем обучении!

======================================================================================================

Андрей, привет!
Спасибо за отправку домашней работы. Однако, я заметил, что код, который ты прислал, не до конца соответствует требованиям задачи.
Согласно условиям необходимо сделать:
- Добавить в класс Friend дополнительную информацию о друзьях, добавить эти поля в конструктор и метод toString. (для этого используй код рассмотренный на воркшопе).
- Проинициализировать массив на этапе объявления (то есть через фигурные скобки).
- Добавить еще несколько друзей (Friend) в массив.
- Вывести новые добавленные данные на экран (System.out.println...).
- Обязательно перед отправкой задания скомпилируй и запусти программу. Убедись что она работает.
- Посмотри как ты инициализируешь переменные в твоем коде - обрати внимание на кавычки (они должны быть " " и закрываться с двух сторон)

======================================================================================================

Попробуй ещё раз изучить лекцию и воркшоп - там достаточно подробно разбираются все эти моменты.
Если у тебя возникли какие-то трудности с выполнением задания, не стесняйтесь обращаться за помощью к команде поддержки - это можно сделать через ТГ чат или с помощью кнопки “задать вопрос” на самой платформе.
Не расстраивайся! Я уверен, что у тебя все получится. Продолжай работать над своим проектом и жду следующую итерацию от тебя.
Удачи!

======================================================================================================

Программирование может быть сложным и иногда требует времени и усилий, чтобы понять его полностью.
Важно продолжать учиться и задавать вопросы, если что-то не понятно.

======================================================================================================

Код выглядит почти правильным, но есть несколько небольших моментов, которые нужно исправить:

1. В методе toString(): добавить аннотацию @Override, + неправильно указаны кавычки (должно быть вот так return "Friend{" + "name='" + name + '\'' + ", age=" + age + ", gender='" + gender + '\'' + ", crank=" + crank + '}';)
2. В конструкторе класса Friend не используется параметр b (у тебя по умолчанию всегда установлен true), который должен быть заменен на crank.
3. Имя переменных типа boolean общепринято начинать со слова is (будет isCrank) - это повышает читаемость кода для других программистов.

После этих исправления - работу будет полностью соответствовать заданию.
Жду от тебя следующую итерацию с исправлениями для зачета задания.  Удачи!

======================================================================================================

Кирилл, привет!
Спасибо за отправку домашней работы!
Решение выглядит почти правильным, но есть несколько небольших вопросов ко второму скриншоту - на нём не видны сегменты syn, syn/ack, ack.
Пришлю примерный скриншот какой необходим (выделил что надо показать на нём).
Продолжайте в том же духе! Я уверен, что у тебя все получится.
Удачи !


п1
п2
Метод можно улучшить, добавив проверку наличия предмета в кеше перед вызовом метода "averageGrade" объекта "inMemoryExamination". Это позволит избежать вызова метода для предмета, оценка которого еще не была посчитана и кеширована.

Вот улучшенный код:

@Override
public Double averageGrade(String subject) {
if (cashed.containsKey(subject)) {
return cashed.get(subject);
} else {
double average = inMemoryExamination.averageGrade(subject);
cashed.put(subject, average);
return average;
}
}

======================================================================================================

Ирина, привет!
Спасибо за отправку домашней работы! Ты отлично постаралась и проделала большую работу!
Твой код хорошо структурирован и понятно написан, что делает его легко читаемым и понятным для других разработчиков.
Код выглядит почти правильным, но есть несколько небольших моментов, которые нужно исправить:
1. Есть ошибка в названии класса. Вместо "CashedExamination" должно быть "CachedExamination", чтобы правильно указать название "Cached" (хранимого) экзамена.
2. Метод averageGrade можно улучшить, добавив проверку наличия предмета в кеше перед вызовом метода "averageGrade" объекта "inMemoryExamination". Это позволит избежать вызова метода для предмета, оценка которого еще не была посчитана и кеширована.
   Возможный пример кода:

   @Override
   public Double averageGrade(String subject) {
        if (cashed.containsKey(subject)) {
            return cashed.get(subject);
        } else {
            double average = inMemoryExamination.averageGrade(subject);
            cashed.put(subject, average);
            return average;
        }
   }

3. Убрать по всему коду неиспользуемые импорты + комментарии не относящиеся к описанию кода.
4. В interface Examination заменить реализацию HashSet<String> allSubjects() на интерфейс (например Set).

Кроме того, я хочу отметить, что ты отлично написала тесты для проверки работы кода! Тесты покрывают все возможные сценарии использования и проверяют корректность работы методов.
Жду от тебя следующую итерацию с исправлениями для зачета задания.
Удачи!

======================================================================================================

Доброе утро, Наталья!
Я посмотрел чаты, в которые ты меня добавила, и у меня возникли несколько вопросов по организации работы.
Я бы хотел уточнить некоторые моменты, чтобы быть более продуктивным и эффективным.

В чатах я заметил, что периодически выкладываются отчеты по проведенным работам.
Мне нужно самостоятельно вести учет выполненных работ, или это делается централизованно?

Также меня интересует, какие работы считаются выполненными - только те, которые проверены со статусом "Принято", или каждая проверка учитывается?
Как происходит оплата за проверенные работы? Какие условия и критерии необходимо выполнить?

Я также заметил, что в чатах пишут о необходимости проверять работы качественно и быстро.
Есть ли какие-то нормативы по времени проверки работы? Я стараюсь делать это максимально быстро, но иногда для полного понимания кода требуется больше времени.

Наконец, я не очень понимаю, что такое SLA. Это расчет, как я понял? Как он выполняется, какие критерии отслеживаются и как понять, что от меня ожидается?
Буду благодарен за разъяснения!

======================================================================================================

Лёня, доброе утро!
Меня добавили в рабочие чаты, и у меня появилось несколько вопросов по организации работы.
Хотел уточнить как происходит оплата за проверенные работы? Какие условия и критерии необходимо выполнять?
P.S. Буду благодарен за разъяснения 🙂

======================================================================================================

Мария, отличная работа!
Программа теперь выводит имена 3-х самых успешных студентов в порядке убывания среднего балла.
Ты продемонстрировал хорошее понимание темы и отлично справился с заданием.
Желаю удачи в дальнейшем обучении!

P.S. Подумай, как можно доработать логику в методе addStudent (он не проверяет, есть ли уже студент с таким именем в TreeSet. Если такой студент уже есть, то новый объект Student с тем же именем и другими баллами все равно будет добавлен в TreeSet).

======================================================================================================

Евгений, отличная работа!
Программа теперь выводит корректную строку.
Ты продемонстрировал хорошее понимание темы и отлично справился с заданием.
Желаю удачи в дальнейшем обучении!

======================================================================================================

Ильнур, привет!
Спасибо за отправку домашней работы!
Код выглядит хорошо организованным и читаемым, но есть несколько небольших моментов, которые нужно исправить:

1. В class TaskDao удалить неиспользуемые импорты и комментарии;

2. Рекомендуется использовать логирование для регистрации ошибок и исключений, вместо прямого использования RuntimeException.
Логгирование помогает исследовать и решать проблемы в приложении;

3. Тесты public void testFindNotFinishedReturnsCorrectTasks() и public void testGetByIdReturnsCorrectTask();
Эта ошибка возникает из-за того, что ожидаемое значение даты создания задачи и фактическое значение даты создания, возвращенное методом getById, отличаются на миллисекунду.
Для решения этой проблемы можно использовать метод truncatedTo(ChronoUnit.MILLIS), который обрезает дату до миллисекунд.
Можно использовать например:
createdDate = LocalDateTime.now().truncatedTo(ChronoUnit.MILLIS);


Продолжайте в том же духе! Я уверен, что у тебя все получится. Продолжай работать над своим проектом и жду следующую итерацию от тебя.
Удачи в дальнейшем обучении!

======================================================================================================

Андрей, привет!
Спасибо за отправку домашней работы!
Мне нравится, что вы использовали Scanner для решения задачи.
Код выглядит хорошо организованным и читаемым, но есть несколько небольших моментов, которые нужно исправить:
1. В строке int[] Array = new int[]{n}; создается массив из одного элемента, равного введенному числу n. Но этот массив не используется в дальнейшем коде и не имеет смысла.
2. Нужно объединить все условия в один блок if-else-if, чтобы избежать повторных проверок = например в условии второго if-оператора if (i % 5 == 0) не учитывается, что число может уже быть заменено на fizz или fizzbuzz.
3. Рассмотри случай если if (i == 0)
4. В блоке else выводится пробел перед числом, что не соответствует заданию. Появляются лишние пробелы при выводе:
Дано число 15. Программа должна вывести:
0 1 2 fizz 4 buzz fizz 7 8 fizz buzz 11 fizz 13 14 fizzbuzz
у тебя выводит:
fizz buzz fizzbuzz  1  2 fizz  3  4 buzz  5 fizz  6  7  8 fizz  9 buzz  10  11 fizz  12  13  14 fizz buzz fizzbuzz

Продолжайте в том же духе! Я уверен, что у тебя все получится. Продолжай работать над своим проектом и жду следующую итерацию от тебя.
Удачи в дальнейшем обучении!

======================================================================================================

Ирина, отличная работа!
Твой код полностью соответствует требованиями и выполняет задание корректно.
Ты продемонстрировала хорошее понимание темы, исправила все замечания и отлично справилась с заданием.
Желаю удачи в дальнейшем обучении!

======================================================================================================

Iurii, привет! Отличная работа!
Код выглядит хорошо организованным и читаемым!!!
Есть несколько некритичных моментов, которые можно улучшить в будущем коде:

в задании 1: можно добавить проверку на null для входного аргумента source и для значений, которые помещаются в новую HashMap.
Также, стоит убедиться, что исходная HashMap не содержит дубликатов значений, которые будут использоваться в качестве ключей новой HashMap.

в задании 3: можно улучшить его эффективность, используя метод addAll() для добавления элементов из HashSet в ArrayList вместо перебора
элементов и добавления их по одному. Также, можно сделать метод void, так как он изменяет переданный ему ArrayList.

Мне нравится, что ты написал тесты (это здорово!) для проверки решения задачи, дал корректные комментарии по коду и правильно ответил на поставленный вопрос в задаче в комментарии к решению.
Ты продемонстрировал хорошее понимание темы и отлично справилась с заданием.
Желаю удачи в дальнейшем обучении!

======================================================================================================

Iurii, привет! Отличная работа!

Твой код выглядит правильным и выполняет задачу корректно. Однако, есть несколько рекомендаций по улучшению:
1. В твоём коде исключается случай когда k = 1, думаю надо добавить всё-таки учитывать не k > 1 , а k >= 1;
2. Можно вместо использования двух указателей start и end, можно использовать один указатель i. Устанавливаем i в 0 и на каждой итерации добавляем в summ элемент source.get(i) и инкрементируем i. Когда i становится равным k, вычисляем среднее и добавляем его в результат.
3. Можно вместо вывода сообщения об ошибке внутри метода selectK, можно выбрасывать исключение IllegalArgumentException, чтобы внешний код легче мог обработать ошибку. В этом случае, замените System.out.println("Incorrect K"); на throw new IllegalArgumentException("Incorrect K");.
4. Рекомендуется добавить проверку на случай, когда source пустой или имеет размер меньше k. В этом случае можно вернуть пустой список или выбросить исключение соответственно.

Продолжайте в том же духе! Я уверен, что у тебя все получится. Продолжай работать над своим проектом и жду следующую итерацию от тебя.

======================================================================================================

Владимир, отличная работа!
Я хотел бы поблагодарить тебя за твою работу и отметить, что ты продемонстрировал отличное понимание материала и умение применять полученные знания на практике.
Твой код написан грамотно и соответствует всем требованиям задания.
Продолжай в том же духе!

Твой код полностью соответствует требованиями и выполняет задание корректно.
Ты продемонстрировал хорошее понимание темы и отлично справился с заданием.
Желаю удачи в дальнейшем обучении!

======================================================================================================

Алексей, отличная работа!
Код выглядит хорошо организованным и читаемым!!!
Есть несколько некритичных моментов, которые можно улучшить в будущем коде:
- я бы добавил скобки {} для всех блоков if-else, чтобы улучшить читаемость кода и убедиться, что каждый блок выполняется корректно.
- вместо использования оператора & использовать оператор &&, что улучшает производительность и ясность кода.
Такой код будет более читаемым и позволит избежать ошибок при добавлении дополнительных операторов в блок в будущем.
Желаю удачи в дальнейшем обучении!

======================================================================================================

Анастасия, отличная работа!
Код выглядит хорошо организованным и читаемым!!!
Есть несколько некритичных моментов, которые можно улучшить в будущем коде: я бы рекомендовал добавить проверку на ввод отрицательного радиуса в конструкторе и методе setRadius, чтобы избежать возможных ошибок в работе программы.
Например можно добавить условие:
if (radius <= 0) {
        throw new IllegalArgumentException("Radius must be positive");
    }
Такой код будет более читаемым и позволит избежать ошибок при добавлении дополнительных операторов в блок в будущем.
Желаю удачи в дальнейшем обучении!

======================================================================================================

Здравствуй, Aleksandr!

Спасибо за отправку ссылок на репозитории и за проделанную работу!
Очень хорошо, что ты добавил зависимость на библиотеку Apache Commons Lang в gradle проекте и использовали ее в коде, добавил зависимость на JUnit 5 и настроил задачу test.
Отлично, что вы создали папку libs и добавили зависимость на jar-файл из другого проекта. Это действительно важный навык, который поможет переиспользовать код и библиотеки в других проектах.

Круто, ты научился добавлять зависимости во все системы сборки! Спасибо за отправку кода и настройки проекта!
Успехов вам в дальнейшей работе!

======================================================================================================

Привет, Anastasia!
Я посмотрел твою работу и поздравляю тебя с тем, что ты успешно справился с написанием домашней работы.
Твой код хорошо структурирован и понятно написан, что делает его легко читаемым и понятным для других разработчиков.
Однако, у меня есть несколько некритичных замечаний, которые могут помочь тебе улучшить свой код в будущем:

1. Используй интерфейс List вместо конкретной реализации ArrayList в сигнатуре метода и внутри метода. Это позволит использовать любую реализацию List в качестве аргумента метода и не привязываться к конкретной реализации внутри метода.
        например:
        public static void getRollingAverage(List<Integer> array, int k) {
2. Вместо использования LinkedList для хранения "окна" размера k, можно использовать обычный массив фиксированного размера k. Это позволит избежать создания новых объектов при добавлении/удалении элементов из "окна".
        например:
        List<Double> result = new ArrayList<>();
        int[] window = new int[k];
        double sum = 0;
3. Добавление проверки на случай, если массив array содержит меньше чем k элементов. В текущей реализации это может привести к ошибке.
        например:
        if (array.size() < k) {
            throw new IllegalArgumentException("Array size must be greater than or equal to k.");
        }

В целом, твоя работа заслуживает похвалы.
Продолжай в том же духе и удачи в дальнейшем изучении Java!

Павел, отличная работа!
Твоё решение полностью соответствует требованиями и выполняет задание корректно.
Ты продемонстрировал хорошее понимание темы и отлично справился с заданием.
Желаю удачи в дальнейшем обучении!

P.S. Про кодировку - это может быть связано с тем, что кодировка терминала не соответствует кодировке, используемой в программе Java. можно попробовать установить кодировку терминала на UTF-8, которая является стандартной кодировкой для работы с символами из разных языков, включая кириллицу.
export LC_ALL=en_US.UTF-8

или можно добавить следующий параметр при запуске программы Java (если первое решение не помогло): java -Dfile.encoding=UTF-8 MyClass
Здесь MyClass - это имя класса, который нужно запустить. Указание параметра -Dfile.encoding=UTF-8 установит кодировку JVM на UTF-8, что должно решить проблему с отображением символов кириллицы.

======================================================================================================

Iurii, привет!
Спасибо за отправку домашней работы!
Твоё решение полностью соответствует требованиями и выполняет задание корректно.
Ты продемонстрировал хорошее понимание темы и отлично справился с заданием.

В данном случае, когда исключение возникает, программа продолжает работу, так как используется блок try-catch, который перехватывает исключение и выводит сообщение об ошибке на экран.
Однако, после этого программа продолжает выполнение.
Если ты хочешь, чтобы программа остановилась при возникновении исключения и не продолжала работу, то нужно либо не использовать блок try-catch, а просто выбрасывать исключение при его возникновении, либо в блоке catch использовать оператор throw для повторного выбрасывания исключения.
Например, вместо блока catch можно написать следующее:
if (exception) {
    throw new RuntimeException("An exception occurred during selectK method execution");
}
Таким образом, если исключение возникнет, программа остановится и выбросит новое исключение с указанным сообщением.

Отличная работа!
Ты хорошо справился с заданием и исправил все ошибки. Особенно хочу отметить, что ты использовал блок try-with-resources для безопасного использования ресурса Scanner input.
Это очень хорошая практика, которая помогает избежать утечек ресурсов и обеспечивает надежность программы.
Продолжай в том же духе!

======================================================================================================

Андрей, привет!
Спасибо за отправку домашней работы!
Я просмотрел оба скриншота - всё выполнено в соответствии с уроком!
Ты продемонстрировал хорошее понимание темы и отлично справился с заданием.
Отличная работа! Продолжай в том же духе!

======================================================================================================

Александра, привет!
Спасибо за отправку домашней работы!
Я посмотрел твою работу и поздравляю тебя с тем, что ты успешно справилась !
Твой код хорошо структурирован и понятно написан, что делает его легко читаемым и понятным для других разработчиков.

Мне нравится, что ты дала корректные комментарии по коду и правильно ответила на поставленный вопрос в задаче и приложила скриншоты.
Ты продемонстрировала хорошее понимание темы желаю удачи в дальнейшем обучении!

PS =>
Однако, у меня есть несколько некритичных замечаний, которые могут помочь тебе улучшить свой код в будущем:

В задании 1 = Вместо двух циклов for можно использовать метод forEach для итерации по элементам map и заполнения changeMap.
В задании 2 = Вместо двух циклов for для заполнения arrayList и linkedList можно использовать метод addAll для добавления всех элементов сразу.

======================================================================================================

Ирина, привет!
Спасибо за отправку домашней работы!
Ты продемонстрировал понимание темы, твой код выглядит хорошо организованным и читаемым!!!
Но есть несколько моментов, которые можно улучшить, например:

1. В методе addStudent можно добавить проверку на null для параметров name и score, чтобы избежать ошибки NullPointerException;
2. В методе top3() можно добавить проверку на размер TreeSet set, чтобы избежать ошибки NoSuchElementException, если set пустой;
  например если добавить меньше 3х студентов (напрмиер 2) получаем NullPointerException
3*(опционально) Можно использовать Stream API для решения задачи, что сделает код более кратким и читаемым.
например можно как то так для N элементов:
List<String> topN(int n) {
    return set.stream()
            .sorted(Comparator.reverseOrder())
            .limit(n)
            .map(Line::getName)
            .collect(Collectors.toList());
}


Продолжай работать над своим проектом и жду следующую итерацию от тебя.
Удачи в дальнейшем обучении!


Задание выполнено корректно. Однако, есть несколько замечаний:

1. В описании Feature не указаны акторы (кто будет использовать функционал) и его цель (зачем это нужно). Например: "Как покупатель, я хочу иметь возможность оформить заказ, чтобы быстро и удобно купить выбранный товар".
2. В сценариях не указаны конкретные шаги заполнения формы доставки и оплаты. Необходимо указать, какие поля нужно заполнить и какие данные вводить.

3. В сценарии "Оформление заказа с ошибками в форме" не указано, какие именно ошибки могут возникнуть при заполнении формы доставки и оплаты. Необходимо добавить конкретные примеры ошибок.

4. В сценарии "Оформление заказа нового пользователя" не указано, какой тип регистрации доступен для новых пользователей (например, через социальные сети или по электронной почте).

5. Необходимо добавить предусловия, которые позволят проверить, что пользователь действительно находится на странице товара и на странице оформления заказа.

6. В сценарии "Оформление заказа нового пользователя" необходимо добавить шаг, который позволит пользователю выбрать, что он хочет зарегистрироваться, а не войти в уже существующий профиль.

7. В сценариях необходимо использовать ключевые слова Gherkin (Given, When, Then) в правильной последовательности и с правильным написанием (например, Given должно начинаться с заглавной буквы).

======================================================================================================

Андрей, привет!
Спасибо за отправку домашней работы!
Я просмотрел оба скриншота - всё выполнено в соответствии с уроком!
Ты продемонстрировал хорошее понимание темы и отлично справился с заданием.
Отличная работа! Продолжай в том же духе!

Есть несколько некритичных замечаний, которые могут помочь тебе улучшить свой код в будущем:
- у тебя на 5 строке в задаче со скобочками лишний // - я бы его удалил
- там же я бы советовал использовать в блоке if-else {} скобки для разграничения блоков и улучшения читаемости
- в задаче с разворотом строки -удалил бы лишние пустые строки в коде (7, 9, 12)

======================================================================================================

Максим, привет!
Спасибо за отправку домашней работы!
Решение выглядит почти правильным, но есть несколько небольших вопросов ко второму скриншоту - на нём не видны сегменты syn, syn/ack, ack.
Пришлю примерный скриншот какой необходим (выделил что надо показать на нём).
Продолжайте в том же духе! Я уверен, что у тебя все получится.
Удачи !

======================================================================================================

Iurii, привет!
Спасибо за отправку домашней работы!
Ты продемонстрировал понимание темы, твой код выглядит хорошо организованным и читаемым!!!
Молодец, что так глубоко погрузился в разбор ТЗ и написал тесты.
Но есть несколько моментов, которые можно улучшить, например:

1. Ошибка в тесте возникает из-за того, что в строке "4,6" используется запятая вместо точки в качестве разделителя десятичных чисел.
В Java десятичные числа должны использовать точку в качестве разделителя.
Чтобы исправить ошибку, необходимо заменить запятую на точку в строке "4,6". Например, можно изменить строку на "4.6".
Попробуй добавить в метод addRecord добавить format = format.replace(",", ".");

2. Также рекомендую в тесты добавлять аннотацию @DisplayName("название_теста") + message (в случае его непрохождения).
Это необходимо для повышения читаемости кода и его понимания другими программистами - тестов бывает очень много)
Пример ниже

    @DisplayName("Тест функции добавления score")
    @Test
    void addScore() {
        score_1.setScore(5);
        scoreDB.addScore(score_1);
        scoreDB.addScore(score_1);
        Score test = scoreDB.getScore(student_1, ListSubject.Alg);
        Assertions.assertEquals(5, test.getScore(), "Expected score = 5, it came incorrectly");
        Assertions.assertEquals(4, test.getCounter(), "Expected score = 4, it came incorrectly");
    }

Продолжай работать над своим проектом и жду следующую итерацию от тебя.
Удачи в дальнейшем обучении!

======================================================================================================

Roman, привет!
Спасибо за отправку домашней работы!
Ты продемонстрировал понимание темы, твой код выглядит хорошо организованным и читаемым!!!
Но есть несколько моментов, которые можно улучшить, например:
у тебя написана в одном приложении конфигурация всем тремя способами.
Можешь прислать 3 архива с кодом, но каждое приложение на Spring должно быть сконфигурированно разными способами или XML, или Java, или Groovy.
Каждое приложение должно запускаться.
Продолжай работать над своим проектом и жду следующую итерацию от тебя.
Удачи в дальнейшем обучении!

======================================================================================================

Ирина, привет!
Спасибо за отправку домашней работы!
Я посмотрел твою работу и поздравляю тебя с тем, что ты успешно справилась с написанием домашней работы.
Ты учла все замечания, которые я указывал - молодец!

Есть ещё несколько некритичных замечаний, которые могут помочь тебе улучшить свой код в будущем:
- В методе addStudent() можно использовать конструктор класса Line для создания нового объекта, вместо создания объекта и установки полей отдельно.
- В методе top3() проверка на отрицательное значение параметра n должна бросать исключение IllegalArgumentException, а не InvalidInputData.

Также от лица всей команды, я хочу пожелать тебе счастливого Нового года!
Желаю тебе достижения всех поставленных целей, осуществления мечт и реализации задуманного.
Также хочу пожелать тебе не забывать обучение и развитие своих навыков, чтобы стать ещё лучше и достигнуть ещё больших высот в будущем!

======================================================================================================

Sergej, cпасибо за отправку домашней работы!
Ты продемонстрировал понимание темы, твой код выглядит хорошо организованным и читаемым!!!

Большинство методов написаны правильно, но есть 4 метода которые необходимо исправить:

1. Разность векторов A и B: твой ответ [3, 3, 3], правильный [-3, -3, -3]
public Vector subtract(Vector other)


2. Длина (норма) вектора A: твой ответ 3.0, правильный 3.7416573867739413
public double length()

3. Matrix A - B:
твой ответ
 1 -2
-2 -2

правильный
-1 2
 2 2

4. Matrix A * B:

твой ответ
2 0
3 8

правильный
 4 4
10 8

Исправь эти методы чтобы они выдавали корректные результаты, если возникнут трудности попробуй еще раз посмотреть материалы из урока.
У тебя всё получится, жду следующую итерацию!

======================================================================================================

Sergej, спасибо за отправку домашней работы!
Я посмотрел твою работу и поздравляю тебя с тем, что ты успешно справился с её написанием.
Ты учёл все замечания, которые я указывал - молодец!

======================================================================================================

Aleksandr, привет!
Спасибо за отправку домашней работы!
Я посмотрел твою работу и поздравляю тебя с тем, что ты успешно справился с её написанием.
Твой код хорошо структурирован и понятно написан, что делает его легко читаемым и понятным для других разработчиков.

Однако, у меня есть несколько некритичных замечаний, которые могут помочь тебе улучшить свой код в будущем:

1. Вместо использования anyString() в методе verify, можно использовать точное значение "Ivan" или "Oleg", т.к. мы знаем, какое значение ожидаем получить.
   + В тестах addProduct_test_existProductUsualDelivery и addProduct_test_existProductFastDelivery можно использовать точное значение "phone" вместо anyString(), так как мы знаем, какой товар ожидаем получить.

2. Для улучшения читаемости кода можно использовать аннотацию @DisplayName для каждого теста, чтобы указать, что именно проверяется в данном тесте.
   например @DisplayName("Тест на получение name у Customer")

3. Можно добавить тесты на исключения, чтобы убедиться, что методы корректно обрабатывает ошибки.

======================================================================================================

Екатерина, привет!
Спасибо за отправку домашней работы!
Я просмотрел оба скриншота - всё выполнено в соответствии с уроком!
Ты продемонстрировала хорошее понимание темы и отлично справилась с заданием.
Отличная работа! Продолжай в том же духе!

Есть несколько некритичных замечаний, которые могут помочь тебе улучшить свой код в будущем:
- я бы советовал использовать в блоке if-else {} скобки для разграничения блоков и улучшения читаемости

======================================================================================================

Сергей, cпасибо за отправку домашней работы!
Ты продемонстрировал понимание темы, твой код выглядит хорошо организованным и читаемым!!!
Все методы написаны правильно, и выдают корректные результаты !
Ты продемонстрировал хорошее понимание темы и отлично справился с заданием.
Отличная работа! Продолжай в том же духе!

======================================================================================================

Iurii, спасибо за отправку домашней работы!
Я посмотрел твою работу и поздравляю тебя с тем, что ты успешно справился с её написанием.
Ты учёл все замечания, которые я указывал - молодец!

======================================================================================================

Камила, привет! Спасибо за отправку домашней работы!
Пришли пожайлуйста файл (архив) твоей программы или ссылку на репозиторий, потому что на скриншоте я вижу только часть функционала из задания.
У тебя всё получится, жду следующую программу!

Если будешь присылать скриншоту пришли обязательно класс Friend, массив с добавлением в него Friends и метод main.

======================================================================================================

Aleksey, cпасибо за отправку домашней работы!
Ты продемонстрировал понимание темы, твой код выглядит хорошо организованным и читаемым!
Большинство методов написаны правильно, но есть метод, который необходимо исправить:

Метод getArea() вычисляет площадь круга с помощью формулы S = πr², где π - число Пи (приблизительно равно 3,14), r - радиус круга.
Однако, в данной реализации формула вычисляет не полную площадь круга, а её половину. Для получения полной площади нужно убрать деление на 2:

    public double getArea() {
        return Math.PI * Math.pow(radius, 2) / 2;
    }

Исправь эти методы чтобы они выдавали корректные результаты, если возникнут трудности попробуй еще раз посмотреть материалы из урока.
У тебя всё получится, жду следующую итерацию!

======================================================================================================

Irina, спасибо за отправку домашней работы!
Ты продемонстрировала понимание темы, твой код выглядит хорошо организованным и читаемым!
Но есть метод, который необходимо исправить:
по п.1 задания = Создай файл со строками вида (x:1,y:5)-(x:2,y:6), описывающими отрезки на плоскости. (в репозитории его нет)
по п.5 задания = Выведи длину в поток вывода. = у тебя выводится сам Segment System.out.println(max.get()); = надо использовать твой метод getLength();

Исправь эти методы чтобы они выдавали корректные результаты, если возникнут трудности попробуй еще раз посмотреть материалы из урока.
У тебя всё получится, жду следующую итерацию!

======================================================================================================

Aleksandr, привет!
Спасибо за отправку домашней работы!
Ты продемонстрировал понимание темы, твой код выглядит хорошо организованным и читаемым!!!
Молодец, что так глубоко погрузился в разбор задания и написал сервис и покрыл его тестами.
Есть несколько некритичных замечаний, которые могут помочь тебе улучшить свой код в будущем:
Например, рекомендую в тесты добавлять аннотацию @DisplayName("название_теста") + message (в случае его непрохождения).
Это необходимо для повышения читаемости кода и его понимания другими программистами - тестов бывает очень много)
Пример ниже
    @DisplayName("Тест функции добавления score")
    @Test
    void addScore() {
        score_1.setScore(5);
        scoreDB.addScore(score_1);
        scoreDB.addScore(score_1);
        Score test = scoreDB.getScore(student_1, ListSubject.Alg);
        Assertions.assertEquals(5, test.getScore(), "Expected score = 5, it came incorrectly");
        Assertions.assertEquals(4, test.getCounter(), "Expected score = 4, it came incorrectly");
    }
Удачи в дальнейшем обучении!

======================================================================================================

Iurii, спасибо за отправку домашней работы!
Ты продемонстрировал понимание темы, твой код выглядит хорошо организованным и читаемым!
Но есть кое-что, что необходимо исправить:
1. метод addStudent - проверь модификатор доступа = если мне потребуется вызвать из метода main какой он должен быть?
2. методе addStudent можно добавить проверку на null для параметров name и score, чтобы избежать ошибки NullPointerException;
3. метод top3() работет некорректно если добавлять меньше 3х студентов (напрмиер 2) получаем NullPointerException. Надо чтобы метод работал корректно с любым кол-вом студентов.
Если возникнут трудности попробуй еще раз посмотреть материалы из урока.
В целом, твоя работа заслуживает похвалы. Продолжай в том же духе!
У тебя всё получится, жду следующую итерацию!

======================================================================================================

Iurii, спасибо за отправку домашней работы!
Молодец, что исправил 3 замечаения = код стал более работоспособен!
Я заметил ещё одну деталь, которую надо изменить:
метод top3() = при добавлении студентов с одинаковым score заменяет их, а не добавляет
например, мы добавим студентов
ResultBoard rb = new ResultBoard();
rb.addStudent("Ivan", 3.0f);
rb.addStudent("Maria", 4.0f);
rb.addStudent("Vlad", 5.0f);
rb.addStudent("Anton", 4.5f);
rb.addStudent("Daria", 1.5f);
rb.addStudent("Vasiliy", 5.0f);
и вызовем метод top3()
System.out.println(rb.top3());
ожидаем что будет вывод [Vlad (у него 5.0f), Vasiliy (у него 5.0f), Anton (у него 4.5f)] или [Vasiliy(у него 5.0f), Vlad(у него 5.0f), Anton(у него 4.5f)]
а получаем : [Vasiliy(у него 5.0f), Anton(у него 4.5f), Maria(у него 4.0f)]
Подумай как это можно исправить - можно попробовать использовать  TreeSet<Student> вместо TreeMap<Float, String> ?
У тебя всё получится, жду следующую итерацию!

======================================================================================================

Irina, спасибо за отправку домашней работы!
Я посмотрел твою работу и поздравляю тебя с тем, что ты успешно справилась с её написанием.
Ты учла все замечания, которые я указывал - молодец!

======================================================================================================

Спасибо за отправку домашней работы, Iurii!
Я оценил твою работу и уверен, что ты хорошо понимаешь тему.
Твой код выглядит читаемым и хорошо организованным.
Однако, я бы хотел отметить два момента, которые нужно исправить.

Во-первых, названия методов должны соответствовать их функционалу. Например, метод readFile() по названию должен считывать файл, а не находить максимальный отрезок.
Поэтому его можно либо разбить на два метода, либо переименовать.

Во-вторых, в методе readFile() нужно закрыть поток BufferedReader после его использования. Это можно сделать с помощью конструкции try-with-resources.

Я хочу похвалить тебя за проделанную работу и уверен, что у тебя все получится в будущем.
Жду с нетерпением следующей итерации!

======================================================================================================

Iurii, спасибо за отправку домашней работы!
Я посмотрел твою работу и поздравляю тебя с тем, что ты успешно справился с её написанием.
Ты учёл все замечания (даже больше - ввёл идентификатор Id), которые я указывал - молодец!

======================================================================================================

Iurii, спасибо за отправку домашней работы!
Я посмотрел твою работу и поздравляю тебя с тем, что ты успешно справился с её написанием.
Ты учёл все замечания, которые я указывал - молодец!

Некритичное замечание - можно использовать только один блок catch для обработки исключений, наследуемых от класса Exception, включая FileNotFoundException и IOException.
Таким образом, вы можете заменить два блока catch на один, который будет перехватывать оба типа исключений.

======================================================================================================

Камила, привет!
Спасибо за отправку домашней работы!
Посмотрел твой код - есть несколько моментов, которые нужно исправить:

1. ты определяешь вначале int i (в цикле for она определяется повторно) =это вызывает ошибку компиляции на твоём скриншоте
    если переменная несет смысл как целое чило из условий задачи, то надо по другому назвать , например
    int n = 20;
    тогда цикл будет
    for (int i = 0; i <= n; i++) {
     ...
     }
2. массив array - ты его создала, но ни разу не используешь
3. в цикле твоё третье условие никогда не будет выполнено т.к. первые два if его опережают
    попробуй цикл с такими условиями:
if (i == 0) { ==> проверка что число n == 0
//...
} else if (i % 3 == 0 && i % 5 == 0) { // ===> fizzbuzz
//...
} else if (i % 3 == 0) { // ===> fizz
//...
 } else if (i % 5 == 0) { //===> buzz
//...
 }

Допиши правильные выводы в условиях цикла.
+ Важно! Обрати внимание на пробелы у тебя указано "fizz buzz" а должно быть "fizzbuzz"

Программирование может быть сложным и иногда требует времени и усилий, чтобы понять его полностью.
Важно продолжать учиться и задавать вопросы, если что-то не понятно!
Я хочу похвалить тебя за проделанную работу и уверен, что у тебя все получится в будущем.
Жду с нетерпением следующей итерации работы!

======================================================================================================

Вадим, спасибо за отправку домашней работы!
Я посмотрел твою работу и поздравляю тебя с тем, что ты успешно справился с её написанием.
Есть несколько некритичных замечаний, которые могут помочь тебе улучшить свой код в будущем:

1. В методе getAverageForSubject переменная avg может быть инициализирована значением 0, поэтому нет необходимости использовать else-блок.
2. В методе lastFiveStudentsWithExcellentMarkOnAnySubject можно заменить ArrayList на LinkedList, так как мы не знаем заранее, сколько элементов будет в списке. LinkedList быстрее добавляет элементы в конец списка и быстрее удаляет элементы из начала списка.
3. Метод containsItem не используется в данной реализации интерфейса Examination, поэтому его можно удалить.
4. В целом, названия переменных и методов соответствуют требованиям Java Code Conventions, но можно добавить комментарии к некоторым методам для лучшего понимания их работы.

Так про тесты, рекомендую в тесты добавлять аннотацию @DisplayName("название_теста") + message (в случае его непрохождения).
Это необходимо для повышения читаемости кода и его понимания другими программистами - тестов бывает очень много)
Пример ниже
    @DisplayName("Тест функции добавления score")
    @Test
    void addScore() {
        score_1.setScore(5);
        scoreDB.addScore(score_1);
        scoreDB.addScore(score_1);
        Score test = scoreDB.getScore(student_1, ListSubject.Alg);
        Assertions.assertEquals(5, test.getScore(), "Expected score = 5, it came incorrectly");
        Assertions.assertEquals(4, test.getCounter(), "Expected score = 4, it came incorrectly");
    }
Удачи в дальнейшем обучении!

======================================================================================================

Эрнест, cпасибо за отправку домашней работы!
Ты продемонстрировал понимание темы, твой код выглядит хорошо организованным и читаемым!!!
Ты отлично справился с заданием!
Отличная работа! Продолжай в том же духе!


======================================================================================================

Iurii, спасибо за отправку домашней работы!

Ты пишешь, что добавил package "practice", для проверки необходимо запускать программу из Main.
Но по ссылке https://github.com/Tayoriko/homework_3_HashMap у тебя такого пакета не обнаружил (возможно ты забыл запушить изменения).
Жду с нетерпением следующей итерации работы!

======================================================================================================

Станислав, спасибо за отправку домашней работы!
Ты продемонстрировал понимание темы, твой код выглядит хорошо организованным и читаемым!
Но есть кое-что, что необходимо исправить:

1. метод addStudent - проверь модификатор доступа = если потребуется вызвать из другого пакета каким он должен быть?

2. методе addStudent можно добавить проверку на null для параметров name и score, чтобы избежать ошибки NullPointerException;

3. метод top3() работет некорректно если добавлять меньше 3х студентов (напрмиер 2) получаем NullPointerException. Надо чтобы метод работал корректно с любым кол-вом студентов.

4. метод top3() = некорректно работает со студентами с одинаковым score
например, мы добавим студентов
ResultBoard rb = new ResultBoard();
rb.addStudent("Ivan", 3.0f);
rb.addStudent("Maria", 4.0f);
rb.addStudent("Vlad", 5.0f);
rb.addStudent("Anton", 4.5f);
rb.addStudent("Daria", 1.5f);
rb.addStudent("Vasiliy", 5.0f);
и вызовем метод top3()
System.out.println(rb.top3());
ожидаем что будет вывод [Vlad (у него 5.0f), Vasiliy (у него 5.0f), Anton (у него 4.5f)] или [Vasiliy(у него 5.0f), Vlad(у него 5.0f), Anton(у него 4.5f)]
а получаем : [Vlad(у него 5.0f), Anton(у него 4.5f), Maria(у него 4.0f)]

Если возникнут трудности попробуй еще раз посмотреть материалы из урока.
В целом, твоя работа заслуживает похвалы. Продолжай в том же духе!
У тебя всё получится, жду следующую итерацию!

======================================================================================================

Aleksey, спасибо за отправку домашней работы!
Ты продемонстрировал понимание темы, твой код выглядит хорошо организованным и читаемым!
Но есть кое-что, что необходимо исправить:
1. надо изенить название переменных для улучшения читаемости кода, например TreeMap<String, Float> treeMap и TreeSet<Student> treeSet надо дать более говорящие называния.
2. метод addStudent - проверь модификатор доступа = если потребуется вызвать из другого пакета каким он должен быть?
3. методе addStudent можно добавить проверку на null для параметров name и score, чтобы избежать ошибки NullPointerException;
4. метод List<Student> top3(float score) = возвращает список из трех студентов, у которых оценка выше или равна заданной в параметре метода, а задание было вывести имена 3-х самых успешных студентов в порядке убывания среднего балла.
Подумай как это можно исправить - можно попробовать использовать  TreeSet<Student> вместо TreeMap<String, Float> ?
+ в методе top3 должно обрабатывать корректно любое кол-во студентов, даже если там 1 студент и 2

Если возникнут трудности попробуй еще раз посмотреть материалы из урока.
В целом, твоя работа заслуживает похвалы. Продолжай в том же духе!
У тебя всё получится, жду следующую итерацию!


======================================================================================================

Iurii, спасибо за отправку домашней работы!

Я посмотрел твою работу и поздравляю тебя с тем, что ты успешно справился с написанием домашней работы.
Твой код хорошо структурирован и понятно написан, что делает его легко читаемым и понятным для других разработчиков.

Однако, у меня есть несколько замечаний, которые могут помочь тебе улучшить свой код в будущем:
1. при выобре меню п4. Read by ID ===>  выводится Please, input ID for delete or 0 for Cancel: 1, хотя ожидаем получение по id а не удаление
2. class OneStudent ===> удалить неиспользуемые импорты
3. Попробуй добавить поддержку кириллицы (добавить символы)
4. В каком методе реализован поиск по 2-м фамилиям? (задание 3, п. 3) - я не обнаружил - прошу уточнить.
В целом, твоя работа заслуживает похвалы - отличная работа! Продолжай в том же духе!

У тебя всё получится, жду следующую итерацию!

======================================================================================================
Aleksey , спасибо за отправку домашней работы!
Я вижу позитивные изменения в коде, но надо кое что ещё исправить.
Сейчас метод top3() = некорректно работает со студентами с одинаковым score
например, мы добавим студентов
ResultBoard rb = new ResultBoard();
rb.addStudent("Ivan", 3.0f);
rb.addStudent("Maria", 4.0f);
rb.addStudent("Vlad", 5.0f);
rb.addStudent("Anton", 4.5f);
rb.addStudent("Daria", 1.5f);
rb.addStudent("Vasiliy", 5.0f);

и вызовем метод top3()

System.out.println(rb.top3());

ожидаем что будет вывод [Vlad (у него 5.0f), Vasiliy (у него 5.0f), Anton (у него 4.5f)] или [Vasiliy(у него 5.0f), Vlad(у него 5.0f), Anton(у него 4.5f)]
а получаем : [Vlad(у него 5.0f), Anton(у него 4.5f), Maria(у него 4.0f)].

Если возникнут трудности попробуй еще раз посмотреть материалы из урока.
В целом, твоя работа заслуживает похвалы. Продолжай в том же духе!
У тебя всё получится, жду следующую итерацию!

======================================================================================================

Привет! На самом деле в методе top3 не так всё сложно как может показаться.
Пришлю тебе пример подобного метода - если возникнут дополнительный вопросы по реализации - пиши

    List<String> top3(int n) throws InvalidInputData {
        if(n < 0) {
          throw   new InvalidInputData("Given a negative number.");
        }
        if(n > set.size()) {
            n = set.size();
        }


        return set.stream()
                .sorted(Comparator.reverseOrder())
                .map(Line::getName)
                .limit(n)
                .collect(Collectors.toList());
    }


или вот без стрима

public List<String> top3(int n) throws InvalidInputData {
        if(n < 0) {
          throw new InvalidInputData("Given a negative number.");
        }
        if(n > set.size()) {
            n = set.size();
        }

        List<Line> sortedLines = new ArrayList<>(set);
        Collections.sort(sortedLines, Collections.reverseOrder());

        List<String> topNames = new ArrayList<>();
        for(int i = 0; i < n; i++) {
            topNames.add(sortedLines.get(i).getName());
        }

        return topNames;


======================================================================================================

Спасибо за отправку домашней работы!
Однако, у меня есть несколько некритичных замечаний, которые могут помочь тебе в будущем:

- Необходимо добавить описание функции в начале файла (например, "Этот файл содержит сценарии функции оформления заказа").
- Следует указать номер сценария перед его описанием (например, "Scenario: 1. Оформление заказа существующего пользователя").
- В сценарии "Оформление заказа с ошибками в форме" можно добавить шаг "And Я вижу поля с ошибками, отмеченные красным цветом".
- В сценариях "Оформление заказа существующего пользователя" и "Оформление заказа нового пользователя" можно добавить шаг "And Я вижу товар в корзине с количеством 1" или аналогичный шаг, чтобы подтвердить, что товар добавлен в корзину.
- Сценарий "Оформление заказа существующего пользователя" можно разбить на несколько более мелких сценариев, чтобы повысить читаемость и понимаемость кода (например, можно выделить сценарий "Добавление товара в корзину").
- Следует добавить примеры для полей формы доставки и оплаты, чтобы понять, какие данные должны быть заполнены.

======================================================================================================

Екатерина, спасибо за отправку домашней работы!

Ты продемонстрировала понимание темы, твой код выглядит хорошо организованным и читаемым!
Но есть кое-что, что необходимо исправить:
1. для ввода данных ты используешь массив = предлагаю использовать просто переменную, например int a;
2. Ты используешь везде println, замени на print т.к. по условию задачи на нужен вывод в строку без переносов
3. Надо разобраться с пробелами чтобы вывод соотетствовал условиям задачи (для 15 0 1 2 fizz 4 buzz fizz 7 8 fizz buzz 11 fizz 13 14 fizzbuzz)
4. Проверь пограничные случаи, если число = 0, вывод должен быть 0 (проверь числа 15, 20, 1 и 0 - какой вывод у них одлжен быть?)

Если возникнут трудности попробуй еще раз посмотреть материалы из урока.
В целом, твоя работа заслуживает похвалы. Продолжай в том же духе!
У тебя всё получится, жду следующую итерацию!

======================================================================================================

Polina, спасибо за отправку домашней работы!
Ты продемонстрировала понимание темы, твой код выглядит хорошо организованным и читаемым!
Прошу тебя прислать архив с твоим кодом или ссылку где я смогу его скачать.
Это необходимо чтобы проверить что программа компилируется и корректно работает (на твоих скриншотах нет запуска программы).
В целом, твоя работа заслуживает похвалы. Продолжай в том же духе!
У тебя всё получится, жду ссылку на программу или архив с программой!


======================================================================================================

Екатерина, спасибо за отправку домашней работы!
Я посмотрел твою работу и поздравляю тебя с тем, что ты успешно справилась с её написанием.
Ты учла все замечания, которые я указывал - молодец!

======================================================================================================

Polina, спасибо за отправку в архиве домашней работы!
Однако, у меня есть несколько замечаний, которые могут помочь тебе улучшить свой код в будущем:

1. В методе getAverageScore необходимо обработать случай, когда список студентов пустой, чтобы избежать деления на ноль.
3. В методе getLastFiveExcellentStudents можно использовать stream API для более компактного кода:
List<String> excellentStudents = students.stream()
    .filter(s -> s.score() == 5)
    .map(Score::name)
    .collect(Collectors.toList());

Отличная работа! Продолжай в том же духе!
У тебя всё получится, жду следующую итерацию!

======================================================================================================

Cпасибо за отправку домашней работы!
Я посмотрел твою работу и поздравляю тебя с тем, что ты успешно справился с её написанием!
Ты учёл все замечания, которые я указывал - молодец!

======================================================================================================

Polina, спасибо за отправку в архиве домашней работы!
Ты продемонстрировала понимание темы, твой код выглядит хорошо организованным и читаемым!
Но есть кое-что, что необходимо исправить:

1. метод addStudent - проверь модификатор доступа = если потребуется вызвать из другого пакета каким он должен быть?

2. методе addStudent можно добавить проверку на null для параметров name и score, чтобы избежать ошибки NullPointerException;

3. метод top3() работает некорректно если добавлять меньше 3х студентов (напрмиер 2) получаем NullPointerException. Надо чтобы метод работал корректно с любым кол-вом студентов.

4. При нескольких вызовах top3() возникает ошибка, потому что в методе top3() ты используешь метод pollFirst() у NavigableSet, который удаляет первый элемент из набора и возвращает его. Если набор пустой, то метод pollFirst() возвращает null.
   В вашем случае, если в NavigableSet меньше трех элементов, то после нескольких вызовов метода pollFirst() он станет пустым, и при следующем вызове метода pollFirst() он вернет null. А затем происходит попытка вызвать метод name у этого null значения, что приводит к ошибке.

5. Убрать лишние выводы System.out.println в методах addStudent (при добавлении) и top3 (на каждой итерации цикла).

Если возникнут трудности попробуй еще раз посмотреть материалы из урока.
В целом, твоя работа заслуживает похвалы. Продолжай в том же духе!
У тебя всё получится, жду следующую итерацию!

======================================================================================================

Aleksandr, cпасибо за отправку домашней работы!
Ты продемонстрировал понимание темы, твой код выглядит хорошо организованным и читаемым!!!
Твои сценарии соответствуют правилам написания хороших BDD тестов BRIEF и могут быть приняты в качестве выполненного задания.
Ты отлично справился с заданием!
Отличная работа! Продолжай в том же духе!

======================================================================================================

Добрый день, Тамара!

Хотел узнать, как прошло мое собеседование и какие результаты были получены.
Я очень заинтересован в этой вакансии и хотел бы получить обратную связь.

Благодарю за ваше время и ожидаю ответа)

======================================================================================================

Привет!

Хочу тебе сказать, что ты молодец! Ты учёл все замечания и даже сделал больше!
Я очень рад, что ты так серьезно отнёсся к этому заданию и продемонстрировал свои знания и навыки.

Но у меня падает часть тестов - прикладываю скриншот.

======================================================================================================

Irina, спасибо за отправку домашней работы!
Есть инструкция для того чтобы настроить сетевое подключение на Mac с Linux, нужно выполнить следующие действия:

1. Откройте терминал в Linux на Mac.
2. Введите команду "sudo nano /etc/network/interfaces" и нажмите Enter.
3. В открывшемся редакторе добавьте следующие строки:

auto eth0
iface eth0 inet dhcp

4. Сохраните изменения, нажав Ctrl+O, затем Enter, и выйдите из редактора, нажав Ctrl+X.
5. Перезагрузите компьютер.

После перезагрузки должно появиться сетевое подключение. Если это не помогло, попробуйте выполнить следующие действия:

1. Откройте терминал в Linux на Mac.
2. Введите команду "sudo nano /etc/NetworkManager/NetworkManager.conf" и нажмите Enter.
3. В открывшемся редакторе найдите строку "managed=false" и замените ее на "managed=true".
4. Сохраните изменения, нажав Ctrl+O, затем Enter, и выйдите из редактора, нажав Ctrl+X.
5. Перезагрузите компьютер.

Если это не помогло, попробуйте установить драйверы для сетевой карты на Mac. Вы можете найти их на сайте производителя вашего Mac.

+++

Сначала попробуй ознакомиться с дополнительными материалами по установке:
Подробная инструкция как установить Linux - https://lifehacker.ru/kak-ustanovit-linux/
Еще одна статья на тему того, как установить данную ОС - https://nastroyvse.ru/opersys/lix/kak-ustanovit-linux.html

======================================================================================================

Отличная работа, Виктория!
Я посмотрел твою работу и поздравляю тебя с тем, что ты успешно справилась с написанием домашней работы!
Твой код хорошо структурирован и понятно написан, что делает его легко читаемым и понятным для других разработчиков.
Твоя домашняя работа была выполнена на высоком уровне!
Я очень рад, что ты так серьезно отнеслась к этому заданию и продемонстрировала свои знания и навыки!
Спасибо за твою работу и удачи в дальнейшем обучении!

======================================================================================================

Аля, cпасибо за отправку домашней работы!
Я изучил твоё решение - ты продемонстрировала понимание темы, твой код выглядит хорошо организованным и читаемым!!!
Все методы написаны правильно, и выдают корректные результаты !
Ты отлично справилась с заданием! Продолжай в том же духе!



======================================================================================================

Игорь , cпасибо за отправку домашней работы!
Я изучил твоё решение - ты продемонстрировал понимание темы, твой код выглядит хорошо организованным и читаемым!!!
Все методы написаны правильно, и выдают корректные результаты !
Ты отлично справился с заданием! Продолжай в том же духе!

======================================================================================================

Cпасибо за отправку домашней работы!
Я посмотрел твою работу и поздравляю тебя с тем, что ты успешно справилась с её написанием!
Ты учла все замечания, которые я указывал - молодец!

======================================================================================================

Привет!

Хочу тебе сказать, что ты молодец! Ты учёл все замечания и даже сделал больше!
Я очень рад, что ты так серьезно отнёсся к этому заданию и продемонстрировал свои знания и навыки.
Все методы написаны правильно, и выдают корректные результаты !
Ты отлично справился с заданием! Продолжай в том же духе!

======================================================================================================

Никита, спасибо за отправку домашней работы!
Я просмотрел оба скриншота - всё выполнено в соответствии с уроком!
Ты продемонстрировал понимание темы и отлично справился с заданием!!
Все методы написаны правильно, и выдают корректные результаты !

Круто что ты продумал грамотный вывод сообщений о друзьях = информация выводится в консоль в форматированном виде.
Отличная работа! Продолжай в том же духе!

======================================================================================================

Аля , спасибо за отправку домашней работы!
Можешь пожалуйста в следующий раз присылать не только скриншоты - а текст или архив с твоей программой (или ссылку где его можно скачать) - это упростит тестирование кода.
Ты продемонстрировала понимание темы, твой код выглядит хорошо организованным и читаемым!
Круто что ты правильно используешь ресурсы (закрыла Scanner) - в дальнейшем ты познакомишься с конструкцией try_with_resources
(если интересно - статься на тему https://www.examclouds.com/ru/java/java-core-russian/try-with-resources)

Но есть несколько моментов, которые надо поправить:

1. Цикл for у тебя начинается с 1 - а по условиям задачи надо с 0 включительно = надо поправить
2. У тебя получается по два пробела между символами в выводе - по условию задачи там по одному - подумай как убрать лишние пробелы
3. if (i % 15 == 0) { я бы рекомендовал заменить на if (number % 3 == 0 & number % 5 == 0)

Обязательно перед отправкой проверь корректность вывода граничных случаев - например 15, 20, 1 и 0.
В целом, твоя работа заслуживает похвалы. Продолжай в том же духе!
У тебя всё получится, жду следующую итерацию!

======================================================================================================

Сергей, cпасибо за отправку домашней работы!
Я изучил твоё решение - ты продемонстрировал понимание темы, твой код выглядит хорошо организованным и читаемым!!!
Все скриншоты полностью соответствуют заданию, и выдают корректные результаты !
Ты отлично справился с заданием!
Продолжай в том же духе!

======================================================================================================

Татьяна , cпасибо за отправку домашней работы!
Я изучил твоё решение - ты продемонстрировала понимание темы, твой код выглядит хорошо организованным и читаемым!!!
Хочу отменить что ты использовала enum - отлично !!!
Все методы написаны правильно, и выдают корректные результаты !
Ты отлично справился с заданием! Продолжай в том же духе!

======================================================================================================

Данил, cпасибо за отправку домашней работы!
Я изучил твоё решение - ты продемонстрировал понимание темы, твой код выглядит хорошо организованным и читаемым!!!
Хочу отменить что ты пользуешься GitHub - это отлично !!!
Все методы написаны правильно, и выдают корректные результаты !
Ты отлично справился с заданием! Продолжай в том же духе!

Однако, у меня есть несколько замечаний, которые могут помочь тебе улучшить свой код в будущем:
- удаляй закомментированные строки (если они не несут какой то важной информации)
- удаляй неиспользуемый импорты

Это поможет улучшить читаемость и чистоту кода

======================================================================================================

Никита, спасибо за отправку домашней работы!
Я просмотрел оба скриншота - всё выполнено в соответствии с уроком!
Ты продемонстрировал понимание темы и отлично справился с заданием!!
Отличная работа! Продолжай в том же духе!

Также рекомендую дополнительно почитать материалы по установке Linux:
Подробная инструкция как установить Linux - https://lifehacker.ru/kak-ustanovit-linux/


======================================================================================================

Ilnur , спасибо за отправку в архиве домашней работы!
Ты продемонстрировал понимание темы, твой код выглядит хорошо организованным и читаемым!
Код выглядит хорошо, но есть несколько моментов, которые можно улучшить:

1. Удаляй закомментированные строки (если они не несут какой то важной информации) и удаляй неиспользуемый импорты.
Это поможет улучшить читаемость и чистоту кода

2. Для чистоты кода надо изменить  @GetMapping("/max_walks") на принятый в проекте -см. контроллеры выше, т.е. должно быть
@GetMapping("/top_10_walking_users")

3. В методе getTop10WalkingUsers() можно добавить обработку исключений, чтобы вернуть пустой список в случае ошибки.

4. В методе getTop10WalkingUsers() можно использовать ResponseEntity вместо List<String>, чтобы вернуть HTTP-статус и тело ответа.

    @GetMapping("/top_10_walking_users")
    public ResponseEntity<List<Walk>> getTop10WalkingUsers() {
        try {
            List<Walk> walks = repository.getTop10WalkingUsersFromDb();
            return new ResponseEntity<>(walks, HttpStatus.OK);
         catch (Exception e) {
            return new ResponseEntity<>(Collections.emptyList(), HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }

ResponseEntity - это класс из Spring Framework, который представляет собой ответ HTTP-запроса.
Использование ResponseEntity позволяет более гибко управлять форматом и содержимым ответа, а также HTTP-статусом и заголовками.
https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/http/ResponseEntity.html

В целом, твоя работа заслуживает похвалы. Продолжай в том же духе!
У тебя всё получится, жду следующую итерацию!

======================================================================================================

Polina, спасибо за отправку в архиве домашней работы!
Ты продемонстрировала понимание темы, твой код выглядит хорошо организованным и читаемым!

Но есть несколько моментов, которые можно улучшить.
Например я думаю надо немного добрабоать парсинг, т.к. когда ты получаешь коориднату надо убирать лишние символы:
Например можно исправить так

            double max = new BufferedReader(new FileReader("untitled18/file/your_file")).lines()
                    .mapToDouble(segment -> {
                        String[] points = segment.replaceAll("\\(/\\)", "").split("-");
                        String[] point1 = points[0].split(",");
                        String[] point2 = points[1].split(",");
                        int x1 = Integer.parseInt(point1[0].split(":")[1]);
              //        int y1 = Integer.parseInt(point1[1].split(" :")[1]);
                        int y1 = Integer.parseInt(point1[1].split(":")[1].substring(0, point1[1].split(":")[1].length() - 1));
                        int x2 = Integer.parseInt(point2[0].split(":")[1]);
              //        int y2 = Integer.parseInt(point2[1].split(":")[1]);
                        int y2 = Integer.parseInt(point2[1].split(":")[1].substring(0, point2[1].split(":")[1].length() - 1));


В целом, твоя работа заслуживает похвалы. Продолжай в том же духе!
У тебя всё получится, жду следующую итерацию!

======================================================================================================

Irina, cпасибо за отправку домашней работы!

Я посмотрел твою работу и поздравляю тебя с тем, что ты успешно справилась с её написанием !!!
Твой код хорошо структурирован и понятно написан, что делает его легко читаемым и понятным для других разработчиков.

Стандартный алгоритм Arrays.sort() имеет более эффективную сложность, чем остальные алгоритмы, что делает его наиболее подходящим для больших массивов или объемов данных. Сортировка вставками (insertionSort) также может быть эффективной для небольших объемов данных.
Важно учитывать, что время выполнения алгоритмов может зависеть от конкретных условий и данных, поэтому необходимо проводить замеры на разных объемах данных и сравнивать результаты.
Скриншот, который вы предоставили, показывает, что при размере массива 10 замеры времени выполнения различных алгоритмов дают примерно одинаковый результат. Однако, для более точной оценки эффективности алгоритмов рекомендуется проводить замеры на больших объемах данных.

Все методы написаны правильно, и выдают корректные результаты !
Ты отлично справилась с заданием! Продолжай в том же духе!

P.S. взял твой код и GitHub = молодец это важный имнструмент для любого разработчика. Молодец что начала им пользоваться!

======================================================================================================

Добрый день, Iurii!
Спасибо за отправку домашней работы!
Я просмотрел оба скриншота - всё выполнено в соответствии с уроком!
Ты продемонстрировал понимание темы и отлично справился с заданием!!
Отличная работа! Продолжай в том же духе!

p.s. да Windows может удивить - да и не только! Впереди будет ещё много удивительной информации)))


======================================================================================================

Добрый вечер, Елена!
Вы проходили в рамках какого другого курса ? Возможно задание там отличалось.
Если это задания уже выполнено Вами - то можете прислать его ко мне на проверку?
Однако, если вы хотите повторить материал и проверить свои знания, вы можете выполнить попробовать домашнее задание на более высоком уровне сложности или другим способом.


======================================================================================================

Добрый вечер, Елена!

Посмотрел - первая задача выполнена отлично! Хорший понятный код - молодец!

Со второй задачей: ошибка заключается в том, что метод ArrayUtils.toObject() не может преобразовать массив примитивных типов, таких как char, в массив объектов Character[].
Для преобразования массива char[] в массив Character[] можно воспользоваться следующим способом:

char[] asd = new char[10];
Character[] arrray = new Character[asd.length];
for (int i = 0; i < asd.length; i++) {
    arrray[i] = asd[i];
}

В этом коде мы создаем новый массив Character[] той же длины, что и исходный массив char[], и затем копируем каждый элемент из asd в соответствующую ячейку нового массива arrray.

Программирование может быть сложным и иногда требует времени и усилий, чтобы понять его полностью.
Важно продолжать учиться и задавать вопросы, если что-то не понятно.
Если возникнут трудности попробуй еще раз посмотреть материалы из урока.
В целом, твоя работа заслуживает похвалы. Продолжай в том же духе!
У тебя всё получится, жду следующую итерацию!

======================================================================================================

Елена, ты продемонстрировала отличное понимание темы и хорошо организовала свой код.
Твой алгоритм работы с использованием стека для хранения открывающих скобок показывает, что ты обладаешь глубоким пониманием задачи и умеешь применять свои знания на практике.

Также стоит отметить, что твой код выглядит очень читаемо и легко понятно, что является важным навыком для любого программиста.

Продолжай развивать свои навыки и уверенно применять их на практике!

======================================================================================================

Добрый день, Irina!
Спасибо за отправку домашней работы!

Задача 1: Решение верное. Метод swapKeysAndValues принимает HashMap<Integer, String>, создает новую HashMap<String, Integer> и перебирает элементы входной HashMap, помещая каждый элемент в новую HashMap в обратном порядке - ключи становятся значениями, а значения - ключами. Результат выводится на экран.

Задача 2: Решение верное. ArrayList представляет собой массив, который имеет быстрый доступ к элементам по индексу, но медленный при вставке и удалении элементов в середине списка. LinkedList же представляет собой связанный список, который имеет быстрый доступ к элементам только по индексу, который нужно искать последовательно, но быстрый при вставке и удалении элементов в середине списка. Поэтому, если требуется часто получать элементы по индексу, то лучше использовать ArrayList, а если требуется часто вставлять и удалять элементы в середине списка, то лучше использовать LinkedList.

Задача 3: Решение выглядит правильным. Однако, следует учитывать, что порядок элементов в итоговом списке может отличаться от исходного, так как HashSet не сохраняет порядок элементов. Если нужно сохранить порядок элементов, можно использовать LinkedHashSet вместо HashSet.

Ты продемонстрировал понимание темы и отлично справился с заданием!!
Отличная работа! Продолжай в том же духе!


======================================================================================================

Добрый день, Вадим!
Спасибо за отправку домашней работы!

Код имеет некоторые ошибки и проблемы:

1. В методе ResultsBoard() происходит печать списка студентов на экран, но этот метод должен быть конструктором класса. Печать списка студентов следует выполнить не в конструкторе, а в отдельном методе, например, в методе printResults().
2. В методе top3() необходимо проверить, что в наборе достаточно записей студентов. Если записей меньше, чем 3, то метод должен возвращать только те записи, которые есть.
3. В методе top3() записи из набора удаляются, что может привести к потере данных в будущем. Рекомендуется использовать методы набора, которые возвращают данные без удаления, например, вместо pollLast() используйте last().

Например можно решить так:
import java.util.*;

public class ResultBoard {
    TreeSet<String> board = new TreeSet<>();

    public ResultBoard() {}

    void addStudent(String name, Float score) {
        board.add(score +" name: "+name);
    }

    public List<String> top3() {
        List<String> uspeh = new ArrayList<>();
        Iterator<String> iterator = board.descendingIterator();
        for (int i = 0; i < 3 && iterator.hasNext(); i++) {
            uspeh.add(iterator.next());
        }
        return uspeh;
    }

    public void printResults() {
        for (String str: board) {
            String[] splitted = str.split(" name: ");
            System.out.println("Name: "+splitted[1]+" Score: "+splitted[0]);
        }
    }

    public static void main(String[] args) {
        ResultsBoard resultBoard = new ResultsBoard();
        resultBoard.addStudent("Ivan Ivanov", 3.823F);
        resultBoard.addStudent("Petr Petrov", 3.225F);
        resultBoard.addStudent("Sidor Sidorov", 3.169F);
        resultBoard.addStudent("Alfred Alfredov", 3.369F);

        // Реализовать структуру, которая хранит записи в порядке возрастания среднего балла.
        resultBoard.printResults();

        // Вывести имена 3-х самых успешных студентов в порядке убывания среднего балла.
        List<String> top3 = resultBoard.top3();
        System.out.println("Three best students:");
        for (String student : top3) {
            String[] splitted = student.split(" name: ");
            System.out.println(splitted[1]);
        }
    }
}

Но я предложил бы подумать насчет того чтобы добавить класс Sudent
class Student implements Comparable<Student>
{
    String name;
    Float score;

...

    @Override
    public int compareTo(Student o) {
    ...
    }

Хранение организовать так
public class ResultBoard
{
    TreeSet <Student> students = new TreeSet<Student>();


В целом, твоя работа заслуживает похвалы. Продолжай в том же духе!
У тебя всё получится, жду следующую итерацию!


======================================================================================================

Хочу тебе сказать, что ты молодец! Ты учла все замечания и даже сделала больше!
Я очень рад, что ты так серьезно отнеслась к этому заданию и продемонстрировала свои знания и навыки.
Все методы написаны правильно, и выдают корректные результаты !
Ты отлично справилась с заданием!
Продолжай в том же духе!

======================================================================================================

Сергей, спасибо за отправку домашней работы!
Я просмотрел скриншот - всё выполнено в соответствии с уроком!
Ты продемонстрировал понимание темы и отлично справился с заданием!!
Отличная работа! Продолжай в том же духе!

Также рекомендую дополнительно почитать материалы по установке Linux:
Подробная инструкция как установить Linux - https://lifehacker.ru/kak-ustanovit-linux/

======================================================================================================

Добрый день, Данил!
Спасибо за отправку домашней работы!
Я просмотрел оба скриншота - но не увидел среди них первую задачу (реализовать алгоритм reverse (перевернуть) для строки) !
Возможно ты забыл его приложить.
Задача со скобочками написана правильно, но нижняя часть с сайта размыта - если можешь - пришли дополнительным скриншотом.

В целом, твоя работа заслуживает похвалы. Продолжай в том же духе!
У тебя всё получится, жду дополнительные скриншоты!


======================================================================================================

Хочу тебе сказать, что ты молодец! Ты учла все замечания!

Осталось исправить буквально пару деталей - чтобы было отлично:
1. Посмотри ты указываешь адрес файла на компьютере = на другом ПК такая программа не найдёт файл (т.к. папка polina у каждого называется по имения своего профиля):
 double max = new BufferedReader(new FileReader("/Users/polina/IdeaProjects/untitled18/src/your_file")).lines()
 используй просто "src/your_file"
2. Удаляй закомментированные строки (если они не несут какой то важной информации)
   Это поможет улучшить читаемость и чистоту кода

В целом, твоя работа заслуживает похвалы. Продолжай в том же духе!
У тебя всё получится, жду следующую итерацию!

======================================================================================================

Данил, спасибо за отправку домашней работы!
Я просмотрел оба скриншота - обе задачи выполнены отлично !
Твой алгоритм работы с использованием стека для хранения открывающих скобок показывает, что ты обладаешь глубоким пониманием задачи и умеешь применять свои знания на практике.
Также стоит отметить, что твой код выглядит очень читаемо и легко понятно, что является важным навыком для любого программиста.
Продолжай развивать свои навыки и уверенно применять их на практике!

======================================================================================================

Доброго времени суток, Елена!
Спасибо за отправку домашней работы! Ты отлично справилась с заданием!
Я просмотрел оба скриншота - всё выполнено в соответствии с уроком!
Также стоит отметить, что твой код выглядит очень читаемо и легко понятно, что является важным навыком для любого программиста.
Продолжай развивать свои навыки и уверенно применять их на практике!

======================================================================================================

Молодец!
Ты продемонстрировала понимание темы и отлично справилась с заданием!!
Отличная работа! Продолжай в том же духе!

======================================================================================================

Молодец!
Ты продемонстрировал понимание темы и отлично справился с заданием!

В твоём наборе тестов проверяются различные значения, включая простые числа и составные числа, а также граничные случаи, такие как 2 и 0.
Тесты покрывают все возможные варианты и должны быть достаточными для проверки правильности реализации метода isPrime.

Отличная работа! Продолжай развивать свои навыки и уверенно применять их на практике!

======================================================================================================
Привет!
ты молодец что разобралась с Git - это крайне важный навык который ты будешь использовать постоянно!)

По коду - надо кое что исправить:
Для вывода информации о каждом друге ты реализовала два независимых метода - но суть задания немного другая.
А именно требуется расширить класс Friend новыми полями.

Например
class Friend {
   private String name;   // имя
   private int age; // возраст
   boolean isFriendFromSchool; // новое поле  - школьный друг или нет
   float hoursSpentTogetherLastWeek; // новое поле - сколько времени провели на этой неделе вместе

// конструктор

   public Friend(String name,
                 int age,
                 boolean isFriendFromSchool,
                 float hoursSpentTogetherLastWeek) {


       this.name = name;
       this.age = age;
       this.isFriendFromSchool = isFriendFromSchool;
       this.hoursSpentTogetherLastWeek = hoursSpentTogetherLastWeek;
   }


// для красвиого вывода кода

   @Override
   public String toString() {
       return "Friend{" +
               "name='" + name + '\'' +
               ", age=" + age +
               ", isFriendFromSchool=" + isFriendFromSchool +
               ", hoursSpentTogetherLastWeek=" + hoursSpentTogetherLastWeek +
               '}';
   }
}

}

Можешь добавить любые поля которые придумаешь.
Далее надо скорректировать данные при добавлении в массив (т.к. там будут дополнительный поля)
 = далее твои два метода не потребуются т.к. мы сможем просто вывести данные из массива со вмести данными

   System.out.println("My friends: " + Arrays.toString(friends));

Также по коду удали лишние строчки (с 35 по 43) - это улучшит читаемость и чистоту кода.

В целом, твоя работа заслуживает похвалы. Продолжай в том же духе!
У тебя всё получится, жду следующую итерацию!

======================================================================================================

Вадим, спасибо за отправку домашней работы!
Я вижу позитивные изменения в коде, но надо кое что ещё исправить.

1. Определить метод toString для Sudent

2. Сейчас метод top3() = некорректно работает со студентами с одинаковым score

например, мы добавим студентов
ResultBoard rb = new ResultBoard();
rb.addStudent("Ivan", 3.0f);
rb.addStudent("Maria", 4.0f);
rb.addStudent("Vlad", 5.0f);
rb.addStudent("Anton", 4.5f);
rb.addStudent("Daria", 1.5f);
rb.addStudent("Vasiliy", 5.0f);

и вызовем метод top3()

System.out.println(rb.top3());

ожидаем что будет вывод [Vlad (у него 5.0f), Vasiliy (у него 5.0f), Anton (у него 4.5f)] или [Vasiliy(у него 5.0f), Vlad(у него 5.0f), Anton(у него 4.5f)]
а получаем : [Vlad(у него 5.0f), Anton(у него 4.5f), Maria(у него 4.0f)].

Если возникнут трудности попробуй еще раз посмотреть материалы из урока.
В целом, твоя работа заслуживает похвалы. Продолжай в том же духе!
У тебя всё получится, жду следующую итерацию!

======================================================================================================

Сергей, спасибо за отправку домашней работы!
Можешь пожалуйста в следующий раз присылать не только скриншоты - а текст или архив с твоей программой (или ссылку где его можно скачать) - это упростит тестирование кода.
Ты продемонстрировал понимание темы, твой код выглядит хорошо организованным и читаемым!
Круто что ты правильно используешь ресурсы (закрыла Scanner) - в дальнейшем ты познакомишься с конструкцией try_with_resources
(если интересно - статься на тему https://www.examclouds.com/ru/java/java-core-russian/try-with-resources)

Но есть несколько моментов, которые надо поправить:

1. Цикл for у тебя начинается с 1 - а по условиям задачи надо с 0 включительно = надо поправить
2. У тебя получается лишние запятые ',' в выводе - по условию задачи там их быть не должно - подумай как убрать лишнее.

Обязательно перед отправкой проверь корректность вывода граничных случаев - например 15, 20, 1 и 0.
В целом, твоя работа заслуживает похвалы. Продолжай в том же духе!
У тебя всё получится, жду следующую итерацию!


======================================================================================================

Спасибо за отправку домашней работы!
Ты продемонстрировала понимание темы, твой код выглядит хорошо организованным и читаемым!
Круто что ты правильно используешь ресурсы (закрыла Scanner) - в дальнейшем ты познакомишься с конструкцией try_with_resources
(если интересно - статья на тему https://www.examclouds.com/ru/java/java-core-russian/try-with-resources)

Но есть несколько моментов, которые надо поправить:

1. Цикл for у тебя начинается с 1 - а по условиям задачи надо с 0 включительно = надо поправить
   Подумай как предусмотреть в ветвлении if-else случай когда n = 0 (что должна вывести программа?)
2. У тебя получается лишние запятые ',' в выводе - по условию задачи там их быть не должно - подумай как убрать лишнее.
3. По codeStyle = название класса должно соответствовать его содержимому и начинаться с Большой буквы. Вместо fizzbuzz можно назвать, например, HomeWork.
4. По codeStyle = удали лишние строчки (с 23 по 27) - это улучшит читаемость и чистоту кода.

Обязательно перед отправкой проверь корректность вывода граничных случаев - например 15, 20, 1 и 0.
В целом ты - молодец! Твой код становится лучше с каждым разом! Продолжай в том же духе!
У тебя всё получится, жду следующую итерацию!

======================================================================================================

Cпасибо за отправку домашней работы!
Ты молодец что разобрался с Git - это крайне важный навык который ты будешь использовать постоянно!)
Ты учёл все замечания и твой код выглядит очень читаемо и легко понятным, что является важным навыком для любого программиста.
Продолжай развивать свои навыки и уверенно применять их на практике!

======================================================================================================

Татьяна, ты продемонстрировала отличное понимание темы и хорошо организовала свой код!
Твой алгоритм работы с использованием стека для хранения открывающих скобок показывает, что ты обладаешь глубоким пониманием задачи и умеешь применять свои знания на практике.
Также стоит отметить, что твой код выглядит очень читаемо и легко понятно, что является важным навыком для любого программиста.
Продолжай развивать свои навыки и уверенно применять их на практике!

======================================================================================================

Спасибо за отправку домашней работы!

Я посмотрел твою работу и поздравляю тебя с тем, что ты успешно справился с её написанием !!!
Твой код хорошо структурирован и понятно написан, что делает его легко читаемым и понятным для других разработчиков.

Стандартный алгоритм Arrays.sort() имеет более эффективную сложность, чем остальные алгоритмы, что делает его наиболее подходящим для больших массивов или объемов данных. Сортировка вставками (insertionSort) также может быть эффективной для небольших объемов данных.
Важно учитывать, что время выполнения алгоритмов может зависеть от конкретных условий и данных, поэтому необходимо проводить замеры на разных объемах данных и сравнивать результаты.
Скриншот, который вы предоставили, показывает, что при размере массива 10 замеры времени выполнения различных алгоритмов дают примерно одинаковый результат. Однако, для более точной оценки эффективности алгоритмов рекомендуется проводить замеры на больших объемах данных.

Ты подготовил отличный ответ !!!

Все методы написаны правильно, и выдают корректные результаты !
Ты отлично справилась с заданием! Продолжай в том же духе!

P.S. взял твой код из GitHub = молодец это важный имнструмент для любого разработчика. Молодец что грамотно ведешь структуру проекта !


======================================================================================================

Спасибо за отправку домашней работы!

Я посмотрел твою работу и поздравляю тебя с тем, что ты успешно справился с её написанием !!!
Твой код хорошо структурирован и понятно написан, что делает его легко читаемым и понятным для других разработчиков.
Решение верное, так как оно содержит корректные SQL-запросы и реализацию методов getAllContacts() и saveAll().
Ты подготовил отличный ответ !
Молодец! Ты продемонстрировал понимание темы и отлично справился с заданием!
Продолжай в том же духе!

Дополнительно советую почитать материалы по теме  https://javarush.com/groups/posts/2172-jdbc-ili-s-chego-vsje-nachinaetsja
или https://blog.skillfactory.ru/glossary/jdbc/

======================================================================================================

Привет!
Супер! Первая задача выполнена верно, но по условию надо ешё проверить, что она проходит тесты на сайте
https://leetcode.com/problems/reverse-string/
и прислать скриншот
там же можно посомтреть алгоритмы и решения (вкладка solution) - но попробуй реализовать сама)


Да вторая задача изначальная сигнатура

class Solution {
    public boolean isValid(String s) {

    }
}

И по требованию к ДЗ - аналогично проверить своё решение на сайте: https://leetcode.com/problems/valid-parentheses/
В целом, твоя работа заслуживает похвалы. Продолжай в том же духе!
У тебя всё получится, жду следующую итерацию!

======================================================================================================

Доброго времени суток, Татьяна!
Спасибо за отправку домашней работы! Ты отлично справилась с заданием!
Я просмотрел скриншота - всё выполнено в соответствии с уроком!
Также стоит отметить, что твой код выглядит очень читаемо и легко понятно, что является важным навыком для любого программиста.
Продолжай развивать свои навыки и уверенно применять их на практике!

======================================================================================================

Юрий, спасибо за отправку в архиве домашней работы!

Отвечаю на вопрос: Строка public ResultsBoard() {} представляет конструктор класса ResultsBoard, который создается при каждом создании объекта этого класса.
В данном случае конструктор не выполняет никаких действий, так как его тело пустое.
Однако, если бы в классе ResultsBoard были какие-то поля, которые нужно было бы инициализировать при создании объекта,
то в теле конструктора можно было бы произвести соответствующую инициализацию. Например, если бы в классе ResultsBoard был список студентов,
то в конструкторе можно было бы создать этот список.


Ты продемонстрировала понимание темы, твой код выглядит хорошо организованным и читаемым!
Но есть кое-что, что необходимо исправить:

1. в методе addStudent можно добавить проверку на null для параметров name и score, чтобы избежать ошибки NullPointerException; Почему ты не хочешь сразу передавать Studen?

2. При нескольких вызовах top3() возникает ошибка, потому что в методе top3() ты используешь метод pollFirst() у NavigableSet, который удаляет первый элемент из набора и возвращает его.
Если набор пустой, то метод pollFirst() возвращает null. В вашем случае, если в NavigableSet меньше трех элементов, то после нескольких вызовов метода pollFirst() он станет пустым, и при следующем вызове метода pollFirst() он вернет null. А затем происходит попытка вызвать метод name у этого null значения, что приводит к ошибке.

3. Сейчас метод top3() = некорректно работает со студентами с одинаковым score

   например, мы добавим студентов
   ResultBoard rb = new ResultBoard();
   rb.addStudent("Ivan", 3.0f);
   rb.addStudent("Maria", 4.0f);
   rb.addStudent("Oleg", 4.0f);

   System.out.println(rb.top3(5)); 		// ожидаем -> [Maria, Oleg, Ivan]

  -> получаем [Student{name='Maria', score=4.0}, Student{name='Ivan', score=3.0}]

  а если вызовем после ещё раз , то из-за pollFirst вообще получим []
  System.out.println(rb.top3(5)); 		// -> []
  System.out.println(rb.top3(5)); 		// -> []

Если возникнут трудности попробуй еще раз посмотреть материалы из урока.
В целом, твоя работа заслуживает похвалы. Продолжай в том же духе!
У тебя всё получится, жду следующую итерацию!


======================================================================================================

Анатолий, спасибо за отправку домашней работы!
Можешь пожалуйста присылать не только скриншоты - а текст или архив с твоей программой (или ссылку где его можно скачать) - это упростит тестирование кода.
+ на скриншоте не видны все тесты
+ результаты некторых методов на скриншоте не соответствуют ожидаемым, например:
 -> ожидается
 Скалярное произведение векторов A и B: 32
 Умножение вектора A на скаляр 2: [2, 4, 6]
 Длина (норма) вектора A: 3.7416573867739413
 Determinant of Matrix H: 28

 Но без кода я не смогу указать где у тебя ошибка (возможно перед отправкой ты сможешь исправить указанные методы)

Если возникнут трудности попробуй еще раз посмотреть материалы из урока.
В целом, твоя работа заслуживает похвалы. Продолжай в том же духе!
У тебя всё получится, жду следующую итерацию!


======================================================================================================

Доброго времени суток!
Спасибо за отправку домашней работы! Ты отлично справился с заданием!
Я просмотрел твой код - ты учёт все замечания - всё выполнено в соответствии с уроком!
Также стоит отметить, что твой код выглядит очень читаемо и легко понятным, что является важным навыком для любого программиста.
Продолжай развивать свои навыки и уверенно применять их на практике!