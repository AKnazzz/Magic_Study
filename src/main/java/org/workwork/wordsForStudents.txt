Наталья, привет! Меня зовут Андрей, я твой код-ревьюер. Поздравляю с написанием работы!
Работа хорошая, но есть несколько замечаний и рекомендаций по улучшению кода:
я рассмотрел два приложенных файла - каждый из них решает часть поставленной задачи:
в первом файле выводится строчка с информацией об имени и возрасте друга,
во втором считывается возраст друга и выводится в консоль.
Попробуй объединить эти два варианта - считать с командной строки и возраст, и имя друга.
А после вывести через System.out.println () согласно форме из задания.
Если возникнут трудности попробуй еще раз посмотреть материалы из урока.
У тебя всё получится, жду следующую итерацию.

======================================================================================================

Наталья, привет! Меня зовут Андрей, я посмотрел твою домашнюю работу. Понимание кода может занять время и требует практики.
Я согласен с тобой, что в видео не всегда удается охватить все моменты.
StringBuilder - это класс в Java, который используется для создания и изменения строк.
Он позволяет создавать строку, добавлять к ней символы и удалять их. StringBuilder эффективнее работает с памятью,
чем обычные строки (String), поэтому он часто используется в Java для работы со строками. В данном случае,
строка result создается с помощью StringBuilder, чтобы в нее можно было добавлять символы в цикле.
Тут можно посмотреть подробнее (https://javarush.com/groups/posts/2351-znakomstvo-so-string-stringbuffer-i-stringbuilder-v-java)
Твоё решение первой задачи является корректным и эффективным - код понятно написан и легко читается, ты отлично используешь материалы пройденные на уроке!
Но надо кое-что исправить - на трочках 13 и 19 у тебя лишник фигурные скобки - их надо удалить.
Подумай как можно решить данную задачу с использованием класса StringBuilder (внимательно почитай про методы данного класса).
Также жду твоё решение по второй задаче. Если возникли трудности с понимание условий задачи или у тебя есть какие-то конкретные вопросы по коду,
я могу помочь тебе разобраться в них.
Программирование может быть сложным и иногда требует времени и усилий, чтобы понять его полностью.
Важно продолжать учиться и задавать вопросы, если что-то не понятно. Я готов помочь тебе, так что не стесняйся обращаться за помощью и продолжай практиковаться!

======================================================================================================

Наталья, отличная работа!
Ваше решение полностью соответствует требованиями и выполняет задание корректно.
Мне нравится, что вы использовали цикл for и условия if / else if / else для решения задачи.
Продолжайте в том же духе! Если у вас возникнут какие-либо вопросы или трудности, не стесняйтесь обращаться за помощью
к команде поддержки - это можно сделать через ТГ чат или с помощью кнопки “задать вопрос” на самой платформе.
Удачи в дальнейшем обучении!

======================================================================================================

Отличная работа, Наталья! Поздравляю тебя с тем, что ты успешно справилась с написанием домашней работы.
Твой код хорошо структурирован и понятно написан, что делает его легко читаемым и понятным для других разработчиков.
Однако, у меня есть несколько некритичных замечаний, которые могут помочь тебе улучшить свой код.
Во-первых, в классе AuthorizationFilter рекомендуется добавить обработку случая, когда сессия не существует, например,
перенаправление на страницу логина.
Во-вторых, по сущности Transaction - у тебя отличное решение и оно правильно используется, но обычно для сущнотей
под доходы и расходы испльзуют правтику высталения флага (например true = доход, false = расход).
В-терьих в классах периодически указано ServletException, которое не будет выброшено - рекомендую удалить в тех случаях где это явно не требуется.

В целом, твоя работа заслуживает похвалы. Продолжай в том же духе и удачи в дальнейшем изучении Java!

======================================================================================================

Наталья, привет!
Спасибо за отправку домашней работы. Однако, я заметил, что файл, который вы прислали, пустой (в части выполнения домашней работы).
Возможно, произошла ошибка при отправке или вы перепутали файлы. Если у вас возникли какие-то трудности с выполнением задания,
не стесняйтесь обращаться за помощью к команде поддержки - это моно сделать через ТГ чат или с помощью кнопки “задать вопрос” на самой платформе.
Напомню что в классе ContactDao необходимо было реализовать написанные методы.

Дополнительно советую изучить материалы по теме
https://javarush.com/groups/posts/2172-jdbc-ili-s-chego-vsje-nachinaetsja
или
https://habr.com/ru/articles/326614/
Если возникнут трудности попробуй еще раз посмотреть материалы из урока (см аналогичный класс AccountDao).
У тебя всё получится, жду следующую итерацию.

======================================================================================================

Отличная работа, Андрей!
Я посмотрел твою работу и поздравляю тебя с тем, что ты успешно справился с написанием домашней работы.
Твой код хорошо структурирован и понятно написан, что делает его легко читаемым и понятным для других разработчиков.
Однако, у меня есть несколько некритичных замечаний, которые могут помочь тебе улучшить свой код в будущем:

1. Имена переменных должны быть написаны в camelCase стиле, то есть первое слово в нижнем регистре,а каждое последующее слово начинается с заглавной буквы. Например, вместо "HomeWorkOne" лучше использовать "HomeworkOne".
2. Хорошей практикой считается объявлять все переменные в начале метода или класса (Scanner), чтобы было проще отслеживать их использование и избежать ошибок.
3. В строке вывода "Моему другу с именем" лучше добавить пробел перед словом " лет", чтобы было читаемее. Также по условию задачи в выводе указаны скобки "<" и ">" - их надо добавить в вывод.
4. Пустые строки в коде также могут быть полезны для улучшения его читаемости. Они могут использоваться для разделения логических блоков кода, чтобы сделать его более структурированным и понятным.

В целом, твоя работа заслуживает похвалы. Продолжай в том же духе и удачи в дальнейшем изучении Java!

======================================================================================================

Отличная работа, Павел!
Я рад сообщить, что твоё задание выполнено отлично и полностью соответствует требованиям.
Ты продемонстрировал хорошее понимание темы и отлично справился с заданием.
Желаю удачи в дальнейшем обучении!

P.S. Для улучшения читаемости кода я советовал бы использовать вместо тернарного оператора для проверки на отрицательное число, использовать метод Math.abs(), который вернет абсолютное значение числа.

======================================================================================================

Привет, Мария!

Я хотел бы похвалить тебя за твою работу и код!
Твой код компилируется и легко читается, а также хорошо оформлен.
Ты проделала хорошую работу, и я уверен, что ты можешь достичь еще больших результатов.
Однако, в тестах в классе main не выводятся имена 3-х самых успешных студентов в порядке убывания среднего балла (с твоими тестовыми данные должно вывестись [Tom, Alex, Jerry]).
Это было хорошо рассмотрено на уроке в воркшопе, и это важная часть задания. Подумай как это можно доработать?

Не расстраивайся! Я уверен, что у тебя все получится. Продолжай работать над своим проектом и жду следующую итерацию от тебя.

Удачи!

======================================================================================================

Евгений, привет!
Спасибо за отправку домашней работы!
Код выглядит почти правильным, но есть несколько небольших моментов, которые нужно исправить:
1. Удалить неиспользуемый import (строка 1);
2. Нужно объединить все условия в один блок if-else-if, чтобы избежать повторных проверок;
3. Вместо System.out.println нужно использовать System.out.print, чтобы все числа и слова выводились в одну строку (тогда вывод будет как в условиях задачи 0 1 2 fizz 4 buzz fizz 7 8 fizz buzz 11 fizz 13 14 fizzbuzz);
4. Нужно добавить проверку на деление на оба числа (3 и 5) и вывод fizzbuzz в этом случае (т.к. это требование условий задачи).

Продолжайте в том же духе! Я уверен, что у тебя все получится. Продолжай работать над своим проектом и жду следующую итерацию от тебя.
Удачи в дальнейшем обучении!

======================================================================================================

Андрей, привет!
Спасибо за отправку домашней работы. Однако, я заметил, что код, который ты прислал, не до конца соответствует требованиям задачи.
Согласно условиям необходимо сделать:
- Добавить в класс Friend дополнительную информацию о друзьях, добавить эти поля в конструктор и метод toString. (для этого используй код рассмотренный на воркшопе).
- Проинициализировать массив на этапе объявления (то есть через фигурные скобки).
- Добавить еще несколько друзей (Friend) в массив.
- Вывести новые добавленные данные на экран (System.out.println...).
- Обязательно перед отправкой задания скомпилируй и запусти программу. Убедись что она работает.
- Посмотри как ты инициализируешь переменные в твоем коде - обрати внимание на кавычки (они должны быть " " и закрываться с двух сторон)

======================================================================================================

Попробуй ещё раз изучить лекцию и воркшоп - там достаточно подробно разбираются все эти моменты.
Если у тебя возникли какие-то трудности с выполнением задания, не стесняйтесь обращаться за помощью к команде поддержки - это можно сделать через ТГ чат или с помощью кнопки “задать вопрос” на самой платформе.
Не расстраивайся! Я уверен, что у тебя все получится. Продолжай работать над своим проектом и жду следующую итерацию от тебя.
Удачи!

======================================================================================================

Программирование может быть сложным и иногда требует времени и усилий, чтобы понять его полностью.
Важно продолжать учиться и задавать вопросы, если что-то не понятно.

======================================================================================================

Код выглядит почти правильным, но есть несколько небольших моментов, которые нужно исправить:

1. В методе toString(): добавить аннотацию @Override, + неправильно указаны кавычки (должно быть вот так return "Friend{" + "name='" + name + '\'' + ", age=" + age + ", gender='" + gender + '\'' + ", crank=" + crank + '}';)
2. В конструкторе класса Friend не используется параметр b (у тебя по умолчанию всегда установлен true), который должен быть заменен на crank.
3. Имя переменных типа boolean общепринято начинать со слова is (будет isCrank) - это повышает читаемость кода для других программистов.

После этих исправления - работу будет полностью соответствовать заданию.
Жду от тебя следующую итерацию с исправлениями для зачета задания.  Удачи!

======================================================================================================

Кирилл, привет!
Спасибо за отправку домашней работы!
Решение выглядит почти правильным, но есть несколько небольших вопросов ко второму скриншоту - на нём не видны сегменты syn, syn/ack, ack.
Пришлю примерный скриншот какой необходим (выделил что надо показать на нём).
Продолжайте в том же духе! Я уверен, что у тебя все получится.
Удачи !


п1
п2
Метод можно улучшить, добавив проверку наличия предмета в кеше перед вызовом метода "averageGrade" объекта "inMemoryExamination". Это позволит избежать вызова метода для предмета, оценка которого еще не была посчитана и кеширована.

Вот улучшенный код:

@Override
public Double averageGrade(String subject) {
if (cashed.containsKey(subject)) {
return cashed.get(subject);
} else {
double average = inMemoryExamination.averageGrade(subject);
cashed.put(subject, average);
return average;
}
}

======================================================================================================

Ирина, привет!
Спасибо за отправку домашней работы! Ты отлично постаралась и проделала большую работу!
Твой код хорошо структурирован и понятно написан, что делает его легко читаемым и понятным для других разработчиков.
Код выглядит почти правильным, но есть несколько небольших моментов, которые нужно исправить:
1. Есть ошибка в названии класса. Вместо "CashedExamination" должно быть "CachedExamination", чтобы правильно указать название "Cached" (хранимого) экзамена.
2. Метод averageGrade можно улучшить, добавив проверку наличия предмета в кеше перед вызовом метода "averageGrade" объекта "inMemoryExamination". Это позволит избежать вызова метода для предмета, оценка которого еще не была посчитана и кеширована.
   Возможный пример кода:

   @Override
   public Double averageGrade(String subject) {
        if (cashed.containsKey(subject)) {
            return cashed.get(subject);
        } else {
            double average = inMemoryExamination.averageGrade(subject);
            cashed.put(subject, average);
            return average;
        }
   }

3. Убрать по всему коду неиспользуемые импорты + комментарии не относящиеся к описанию кода.
4. В interface Examination заменить реализацию HashSet<String> allSubjects() на интерфейс (например Set).

Кроме того, я хочу отметить, что ты отлично написала тесты для проверки работы кода! Тесты покрывают все возможные сценарии использования и проверяют корректность работы методов.
Жду от тебя следующую итерацию с исправлениями для зачета задания.
Удачи!

======================================================================================================

Доброе утро, Наталья!
Я посмотрел чаты, в которые ты меня добавила, и у меня возникли несколько вопросов по организации работы.
Я бы хотел уточнить некоторые моменты, чтобы быть более продуктивным и эффективным.

В чатах я заметил, что периодически выкладываются отчеты по проведенным работам.
Мне нужно самостоятельно вести учет выполненных работ, или это делается централизованно?

Также меня интересует, какие работы считаются выполненными - только те, которые проверены со статусом "Принято", или каждая проверка учитывается?
Как происходит оплата за проверенные работы? Какие условия и критерии необходимо выполнить?

Я также заметил, что в чатах пишут о необходимости проверять работы качественно и быстро.
Есть ли какие-то нормативы по времени проверки работы? Я стараюсь делать это максимально быстро, но иногда для полного понимания кода требуется больше времени.

Наконец, я не очень понимаю, что такое SLA. Это расчет, как я понял? Как он выполняется, какие критерии отслеживаются и как понять, что от меня ожидается?
Буду благодарен за разъяснения!

======================================================================================================

Лёня, доброе утро!
Меня добавили в рабочие чаты, и у меня появилось несколько вопросов по организации работы.
Хотел уточнить как происходит оплата за проверенные работы? Какие условия и критерии необходимо выполнять?
P.S. Буду благодарен за разъяснения 🙂

======================================================================================================

Мария, отличная работа!
Программа теперь выводит имена 3-х самых успешных студентов в порядке убывания среднего балла.
Ты продемонстрировал хорошее понимание темы и отлично справился с заданием.
Желаю удачи в дальнейшем обучении!

P.S. Подумай, как можно доработать логику в методе addStudent (он не проверяет, есть ли уже студент с таким именем в TreeSet. Если такой студент уже есть, то новый объект Student с тем же именем и другими баллами все равно будет добавлен в TreeSet).

======================================================================================================

Евгений, отличная работа!
Программа теперь выводит корректную строку.
Ты продемонстрировал хорошее понимание темы и отлично справился с заданием.
Желаю удачи в дальнейшем обучении!

======================================================================================================

Ильнур, привет!
Спасибо за отправку домашней работы!
Код выглядит хорошо организованным и читаемым, но есть несколько небольших моментов, которые нужно исправить:

1. В class TaskDao удалить неиспользуемые импорты и комментарии;

2. Рекомендуется использовать логирование для регистрации ошибок и исключений, вместо прямого использования RuntimeException.
Логгирование помогает исследовать и решать проблемы в приложении;

3. Тесты public void testFindNotFinishedReturnsCorrectTasks() и public void testGetByIdReturnsCorrectTask();
Эта ошибка возникает из-за того, что ожидаемое значение даты создания задачи и фактическое значение даты создания, возвращенное методом getById, отличаются на миллисекунду.
Для решения этой проблемы можно использовать метод truncatedTo(ChronoUnit.MILLIS), который обрезает дату до миллисекунд.
Можно использовать например:
createdDate = LocalDateTime.now().truncatedTo(ChronoUnit.MILLIS);


Продолжайте в том же духе! Я уверен, что у тебя все получится. Продолжай работать над своим проектом и жду следующую итерацию от тебя.
Удачи в дальнейшем обучении!

======================================================================================================

Андрей, привет!
Спасибо за отправку домашней работы!
Мне нравится, что вы использовали Scanner для решения задачи.
Код выглядит хорошо организованным и читаемым, но есть несколько небольших моментов, которые нужно исправить:
1. В строке int[] Array = new int[]{n}; создается массив из одного элемента, равного введенному числу n. Но этот массив не используется в дальнейшем коде и не имеет смысла.
2. Нужно объединить все условия в один блок if-else-if, чтобы избежать повторных проверок = например в условии второго if-оператора if (i % 5 == 0) не учитывается, что число может уже быть заменено на fizz или fizzbuzz.
3. Рассмотри случай если if (i == 0)
4. В блоке else выводится пробел перед числом, что не соответствует заданию. Появляются лишние пробелы при выводе:
Дано число 15. Программа должна вывести:
0 1 2 fizz 4 buzz fizz 7 8 fizz buzz 11 fizz 13 14 fizzbuzz
у тебя выводит:
fizz buzz fizzbuzz  1  2 fizz  3  4 buzz  5 fizz  6  7  8 fizz  9 buzz  10  11 fizz  12  13  14 fizz buzz fizzbuzz

Продолжайте в том же духе! Я уверен, что у тебя все получится. Продолжай работать над своим проектом и жду следующую итерацию от тебя.
Удачи в дальнейшем обучении!

======================================================================================================

Ирина, отличная работа!
Твой код полностью соответствует требованиями и выполняет задание корректно.
Ты продемонстрировала хорошее понимание темы, исправила все замечания и отлично справилась с заданием.
Желаю удачи в дальнейшем обучении!

======================================================================================================

Iurii, привет! Отличная работа!
Код выглядит хорошо организованным и читаемым!!!
Есть несколько некритичных моментов, которые можно улучшить в будущем коде:

в задании 1: можно добавить проверку на null для входного аргумента source и для значений, которые помещаются в новую HashMap.
Также, стоит убедиться, что исходная HashMap не содержит дубликатов значений, которые будут использоваться в качестве ключей новой HashMap.

в задании 3: можно улучшить его эффективность, используя метод addAll() для добавления элементов из HashSet в ArrayList вместо перебора
элементов и добавления их по одному. Также, можно сделать метод void, так как он изменяет переданный ему ArrayList.

Мне нравится, что ты написал тесты (это здорово!) для проверки решения задачи, дал корректные комментарии по коду и правильно ответил на поставленный вопрос в задаче в комментарии к решению.
Ты продемонстрировал хорошее понимание темы и отлично справилась с заданием.
Желаю удачи в дальнейшем обучении!

======================================================================================================

Iurii, привет! Отличная работа!

Твой код выглядит правильным и выполняет задачу корректно. Однако, есть несколько рекомендаций по улучшению:
1. В твоём коде исключается случай когда k = 1, думаю надо добавить всё-таки учитывать не k > 1 , а k >= 1;
2. Можно вместо использования двух указателей start и end, можно использовать один указатель i. Устанавливаем i в 0 и на каждой итерации добавляем в summ элемент source.get(i) и инкрементируем i. Когда i становится равным k, вычисляем среднее и добавляем его в результат.
3. Можно вместо вывода сообщения об ошибке внутри метода selectK, можно выбрасывать исключение IllegalArgumentException, чтобы внешний код легче мог обработать ошибку. В этом случае, замените System.out.println("Incorrect K"); на throw new IllegalArgumentException("Incorrect K");.
4. Рекомендуется добавить проверку на случай, когда source пустой или имеет размер меньше k. В этом случае можно вернуть пустой список или выбросить исключение соответственно.

Продолжайте в том же духе! Я уверен, что у тебя все получится. Продолжай работать над своим проектом и жду следующую итерацию от тебя.

======================================================================================================

Владимир, отличная работа!
Я хотел бы поблагодарить тебя за твою работу и отметить, что ты продемонстрировал отличное понимание материала и умение применять полученные знания на практике.
Твой код написан грамотно и соответствует всем требованиям задания.
Продолжай в том же духе!

Твой код полностью соответствует требованиями и выполняет задание корректно.
Ты продемонстрировал хорошее понимание темы и отлично справился с заданием.
Желаю удачи в дальнейшем обучении!

======================================================================================================

Алексей, отличная работа!
Код выглядит хорошо организованным и читаемым!!!
Есть несколько некритичных моментов, которые можно улучшить в будущем коде:
- я бы добавил скобки {} для всех блоков if-else, чтобы улучшить читаемость кода и убедиться, что каждый блок выполняется корректно.
- вместо использования оператора & использовать оператор &&, что улучшает производительность и ясность кода.
Такой код будет более читаемым и позволит избежать ошибок при добавлении дополнительных операторов в блок в будущем.
Желаю удачи в дальнейшем обучении!

======================================================================================================

Анастасия, отличная работа!
Код выглядит хорошо организованным и читаемым!!!
Есть несколько некритичных моментов, которые можно улучшить в будущем коде: я бы рекомендовал добавить проверку на ввод отрицательного радиуса в конструкторе и методе setRadius, чтобы избежать возможных ошибок в работе программы.
Например можно добавить условие:
if (radius <= 0) {
        throw new IllegalArgumentException("Radius must be positive");
    }
Такой код будет более читаемым и позволит избежать ошибок при добавлении дополнительных операторов в блок в будущем.
Желаю удачи в дальнейшем обучении!

======================================================================================================

Здравствуй, Aleksandr!

Спасибо за отправку ссылок на репозитории и за проделанную работу!
Очень хорошо, что ты добавил зависимость на библиотеку Apache Commons Lang в gradle проекте и использовали ее в коде, добавил зависимость на JUnit 5 и настроил задачу test.
Отлично, что вы создали папку libs и добавили зависимость на jar-файл из другого проекта. Это действительно важный навык, который поможет переиспользовать код и библиотеки в других проектах.

Круто, ты научился добавлять зависимости во все системы сборки! Спасибо за отправку кода и настройки проекта!
Успехов вам в дальнейшей работе!

======================================================================================================

Привет, Anastasia!
Я посмотрел твою работу и поздравляю тебя с тем, что ты успешно справился с написанием домашней работы.
Твой код хорошо структурирован и понятно написан, что делает его легко читаемым и понятным для других разработчиков.
Однако, у меня есть несколько некритичных замечаний, которые могут помочь тебе улучшить свой код в будущем:

1. Используй интерфейс List вместо конкретной реализации ArrayList в сигнатуре метода и внутри метода. Это позволит использовать любую реализацию List в качестве аргумента метода и не привязываться к конкретной реализации внутри метода.
        например:
        public static void getRollingAverage(List<Integer> array, int k) {
2. Вместо использования LinkedList для хранения "окна" размера k, можно использовать обычный массив фиксированного размера k. Это позволит избежать создания новых объектов при добавлении/удалении элементов из "окна".
        например:
        List<Double> result = new ArrayList<>();
        int[] window = new int[k];
        double sum = 0;
3. Добавление проверки на случай, если массив array содержит меньше чем k элементов. В текущей реализации это может привести к ошибке.
        например:
        if (array.size() < k) {
            throw new IllegalArgumentException("Array size must be greater than or equal to k.");
        }

В целом, твоя работа заслуживает похвалы.
Продолжай в том же духе и удачи в дальнейшем изучении Java!

Павел, отличная работа!
Твоё решение полностью соответствует требованиями и выполняет задание корректно.
Ты продемонстрировал хорошее понимание темы и отлично справился с заданием.
Желаю удачи в дальнейшем обучении!

P.S. Про кодировку - это может быть связано с тем, что кодировка терминала не соответствует кодировке, используемой в программе Java. можно попробовать установить кодировку терминала на UTF-8, которая является стандартной кодировкой для работы с символами из разных языков, включая кириллицу.
export LC_ALL=en_US.UTF-8

или можно добавить следующий параметр при запуске программы Java (если первое решение не помогло): java -Dfile.encoding=UTF-8 MyClass
Здесь MyClass - это имя класса, который нужно запустить. Указание параметра -Dfile.encoding=UTF-8 установит кодировку JVM на UTF-8, что должно решить проблему с отображением символов кириллицы.

======================================================================================================

Iurii, привет!
Спасибо за отправку домашней работы!
Твоё решение полностью соответствует требованиями и выполняет задание корректно.
Ты продемонстрировал хорошее понимание темы и отлично справился с заданием.

В данном случае, когда исключение возникает, программа продолжает работу, так как используется блок try-catch, который перехватывает исключение и выводит сообщение об ошибке на экран.
Однако, после этого программа продолжает выполнение.
Если ты хочешь, чтобы программа остановилась при возникновении исключения и не продолжала работу, то нужно либо не использовать блок try-catch, а просто выбрасывать исключение при его возникновении, либо в блоке catch использовать оператор throw для повторного выбрасывания исключения.
Например, вместо блока catch можно написать следующее:
if (exception) {
    throw new RuntimeException("An exception occurred during selectK method execution");
}
Таким образом, если исключение возникнет, программа остановится и выбросит новое исключение с указанным сообщением.

Отличная работа!
Ты хорошо справился с заданием и исправил все ошибки. Особенно хочу отметить, что ты использовал блок try-with-resources для безопасного использования ресурса Scanner input.
Это очень хорошая практика, которая помогает избежать утечек ресурсов и обеспечивает надежность программы.
Продолжай в том же духе!

======================================================================================================

Андрей, привет!
Спасибо за отправку домашней работы!
Я просмотрел оба скриншота - всё выполнено в соответствии с уроком!
Ты продемонстрировал хорошее понимание темы и отлично справился с заданием.
Отличная работа! Продолжай в том же духе!

======================================================================================================

Александра, привет!
Спасибо за отправку домашней работы!
Я посмотрел твою работу и поздравляю тебя с тем, что ты успешно справилась !
Твой код хорошо структурирован и понятно написан, что делает его легко читаемым и понятным для других разработчиков.

Мне нравится, что ты дала корректные комментарии по коду и правильно ответила на поставленный вопрос в задаче и приложила скриншоты.
Ты продемонстрировала хорошее понимание темы желаю удачи в дальнейшем обучении!

PS =>
Однако, у меня есть несколько некритичных замечаний, которые могут помочь тебе улучшить свой код в будущем:

В задании 1 = Вместо двух циклов for можно использовать метод forEach для итерации по элементам map и заполнения changeMap.
В задании 2 = Вместо двух циклов for для заполнения arrayList и linkedList можно использовать метод addAll для добавления всех элементов сразу.

======================================================================================================

Ирина, привет!
Спасибо за отправку домашней работы!
Ты продемонстрировал понимание темы, твой код выглядит хорошо организованным и читаемым!!!
Но есть несколько моментов, которые можно улучшить, например:

1. В методе addStudent можно добавить проверку на null для параметров name и score, чтобы избежать ошибки NullPointerException;
2. В методе top3() можно добавить проверку на размер TreeSet set, чтобы избежать ошибки NoSuchElementException, если set пустой;
  например если добавить меньше 3х студентов (напрмиер 2) получаем NullPointerException
3*(опционально) Можно использовать Stream API для решения задачи, что сделает код более кратким и читаемым.
например можно как то так для N элементов:
List<String> topN(int n) {
    return set.stream()
            .sorted(Comparator.reverseOrder())
            .limit(n)
            .map(Line::getName)
            .collect(Collectors.toList());
}


Продолжай работать над своим проектом и жду следующую итерацию от тебя.
Удачи в дальнейшем обучении!


Задание выполнено корректно. Однако, есть несколько замечаний:

1. В описании Feature не указаны акторы (кто будет использовать функционал) и его цель (зачем это нужно). Например: "Как покупатель, я хочу иметь возможность оформить заказ, чтобы быстро и удобно купить выбранный товар".
2. В сценариях не указаны конкретные шаги заполнения формы доставки и оплаты. Необходимо указать, какие поля нужно заполнить и какие данные вводить.

3. В сценарии "Оформление заказа с ошибками в форме" не указано, какие именно ошибки могут возникнуть при заполнении формы доставки и оплаты. Необходимо добавить конкретные примеры ошибок.

4. В сценарии "Оформление заказа нового пользователя" не указано, какой тип регистрации доступен для новых пользователей (например, через социальные сети или по электронной почте).

5. Необходимо добавить предусловия, которые позволят проверить, что пользователь действительно находится на странице товара и на странице оформления заказа.

6. В сценарии "Оформление заказа нового пользователя" необходимо добавить шаг, который позволит пользователю выбрать, что он хочет зарегистрироваться, а не войти в уже существующий профиль.

7. В сценариях необходимо использовать ключевые слова Gherkin (Given, When, Then) в правильной последовательности и с правильным написанием (например, Given должно начинаться с заглавной буквы).

======================================================================================================

Андрей, привет!
Спасибо за отправку домашней работы!
Я просмотрел оба скриншота - всё выполнено в соответствии с уроком!
Ты продемонстрировал хорошее понимание темы и отлично справился с заданием.
Отличная работа! Продолжай в том же духе!

Есть несколько некритичных замечаний, которые могут помочь тебе улучшить свой код в будущем:
- у тебя на 5 строке в задаче со скобочками лишний // - я бы его удалил
- там же я бы советовал использовать в блоке if-else {} скобки для разграничения блоков и улучшения читаемости
- в задаче с разворотом строки -удалил бы лишние пустые строки в коде (7, 9, 12)

======================================================================================================

Максим, привет!
Спасибо за отправку домашней работы!
Решение выглядит почти правильным, но есть несколько небольших вопросов ко второму скриншоту - на нём не видны сегменты syn, syn/ack, ack.
Пришлю примерный скриншот какой необходим (выделил что надо показать на нём).
Продолжайте в том же духе! Я уверен, что у тебя все получится.
Удачи !

======================================================================================================

Iurii, привет!
Спасибо за отправку домашней работы!
Ты продемонстрировал понимание темы, твой код выглядит хорошо организованным и читаемым!!!
Молодец, что так глубоко погрузился в разбор ТЗ и написал тесты.
Но есть несколько моментов, которые можно улучшить, например:

1. Ошибка в тесте возникает из-за того, что в строке "4,6" используется запятая вместо точки в качестве разделителя десятичных чисел.
В Java десятичные числа должны использовать точку в качестве разделителя.
Чтобы исправить ошибку, необходимо заменить запятую на точку в строке "4,6". Например, можно изменить строку на "4.6".
Попробуй добавить в метод addRecord добавить format = format.replace(",", ".");

2. Также рекомендую в тесты добавлять аннотацию @DisplayName("название_теста") + message (в случае его непрохождения).
Это необходимо для повышения читаемости кода и его понимания другими программистами - тестов бывает очень много)
Пример ниже

    @DisplayName("Тест функции добавления score")
    @Test
    void addScore() {
        score_1.setScore(5);
        scoreDB.addScore(score_1);
        scoreDB.addScore(score_1);
        Score test = scoreDB.getScore(student_1, ListSubject.Alg);
        Assertions.assertEquals(5, test.getScore(), "Expected score = 5, it came incorrectly");
        Assertions.assertEquals(4, test.getCounter(), "Expected score = 4, it came incorrectly");
    }

Продолжай работать над своим проектом и жду следующую итерацию от тебя.
Удачи в дальнейшем обучении!

======================================================================================================

Roman, привет!
Спасибо за отправку домашней работы!
Ты продемонстрировал понимание темы, твой код выглядит хорошо организованным и читаемым!!!
Но есть несколько моментов, которые можно улучшить, например:
у тебя написана в одном приложении конфигурация всем тремя способами.
Можешь прислать 3 архива с кодом, но каждое приложение на Spring должно быть сконфигурированно разными способами или XML, или Java, или Groovy.
Каждое приложение должно запускаться.
Продолжай работать над своим проектом и жду следующую итерацию от тебя.
Удачи в дальнейшем обучении!

======================================================================================================

Ирина, привет!
Спасибо за отправку домашней работы!
Я посмотрел твою работу и поздравляю тебя с тем, что ты успешно справилась с написанием домашней работы.
Ты учла все замечания, которые я указывал - молодец!

Есть ещё несколько некритичных замечаний, которые могут помочь тебе улучшить свой код в будущем:
- В методе addStudent() можно использовать конструктор класса Line для создания нового объекта, вместо создания объекта и установки полей отдельно.
- В методе top3() проверка на отрицательное значение параметра n должна бросать исключение IllegalArgumentException, а не InvalidInputData.

Также от лица всей команды, я хочу пожелать тебе счастливого Нового года!
Желаю тебе достижения всех поставленных целей, осуществления мечт и реализации задуманного.
Также хочу пожелать тебе не забывать обучение и развитие своих навыков, чтобы стать ещё лучше и достигнуть ещё больших высот в будущем!

======================================================================================================

Sergej, cпасибо за отправку домашней работы!
Ты продемонстрировал понимание темы, твой код выглядит хорошо организованным и читаемым!!!

Большинство методов написаны правильно, но есть 4 метода которые необходимо исправить:

1. Разность векторов A и B: твой ответ [3, 3, 3], правильный [-3, -3, -3]
public Vector subtract(Vector other)


2. Длина (норма) вектора A: твой ответ 3.0, правильный 3.7416573867739413
public double length()

3. Matrix A - B:
твой ответ
 1 -2
-2 -2

правильный
-1 2
 2 2

4. Matrix A * B:

твой ответ
2 0
3 8

правильный
 4 4
10 8

Исправь эти методы чтобы они выдавали корректные результаты, если возникнут трудности попробуй еще раз посмотреть материалы из урока.
У тебя всё получится, жду следующую итерацию!

======================================================================================================

Sergej, спасибо за отправку домашней работы!
Я посмотрел твою работу и поздравляю тебя с тем, что ты успешно справился с её написанием.
Ты учёл все замечания, которые я указывал - молодец!

======================================================================================================

Aleksandr, привет!
Спасибо за отправку домашней работы!
Я посмотрел твою работу и поздравляю тебя с тем, что ты успешно справился с её написанием.
Твой код хорошо структурирован и понятно написан, что делает его легко читаемым и понятным для других разработчиков.

Однако, у меня есть несколько некритичных замечаний, которые могут помочь тебе улучшить свой код в будущем:

1. Вместо использования anyString() в методе verify, можно использовать точное значение "Ivan" или "Oleg", т.к. мы знаем, какое значение ожидаем получить.
   + В тестах addProduct_test_existProductUsualDelivery и addProduct_test_existProductFastDelivery можно использовать точное значение "phone" вместо anyString(), так как мы знаем, какой товар ожидаем получить.

2. Для улучшения читаемости кода можно использовать аннотацию @DisplayName для каждого теста, чтобы указать, что именно проверяется в данном тесте.
   например @DisplayName("Тест на получение name у Customer")

3. Можно добавить тесты на исключения, чтобы убедиться, что методы корректно обрабатывает ошибки.

======================================================================================================

Екатерина, привет!
Спасибо за отправку домашней работы!
Я просмотрел оба скриншота - всё выполнено в соответствии с уроком!
Ты продемонстрировала хорошее понимание темы и отлично справилась с заданием.
Отличная работа! Продолжай в том же духе!

Есть несколько некритичных замечаний, которые могут помочь тебе улучшить свой код в будущем:
- я бы советовал использовать в блоке if-else {} скобки для разграничения блоков и улучшения читаемости

======================================================================================================

Сергей, cпасибо за отправку домашней работы!
Ты продемонстрировал понимание темы, твой код выглядит хорошо организованным и читаемым!!!
Все методы написаны правильно, и выдают корректные результаты !
Ты продемонстрировал хорошее понимание темы и отлично справился с заданием.
Отличная работа! Продолжай в том же духе!

======================================================================================================

Iurii, спасибо за отправку домашней работы!
Я посмотрел твою работу и поздравляю тебя с тем, что ты успешно справился с её написанием.
Ты учёл все замечания, которые я указывал - молодец!

======================================================================================================

Камила, привет! Спасибо за отправку домашней работы!
Пришли пожайлуйста файл (архив) твоей программы или ссылку на репозиторий, потому что на скриншоте я вижу только часть функционала из задания.
У тебя всё получится, жду следующую программу!

Если будешь присылать скриншоту пришли обязательно класс Friend, массив с добавлением в него Friends и метод main.

======================================================================================================

Aleksey, cпасибо за отправку домашней работы!
Ты продемонстрировал понимание темы, твой код выглядит хорошо организованным и читаемым!
Большинство методов написаны правильно, но есть метод, который необходимо исправить:

Метод getArea() вычисляет площадь круга с помощью формулы S = πr², где π - число Пи (приблизительно равно 3,14), r - радиус круга.
Однако, в данной реализации формула вычисляет не полную площадь круга, а её половину. Для получения полной площади нужно убрать деление на 2:

    public double getArea() {
        return Math.PI * Math.pow(radius, 2) / 2;
    }

Исправь эти методы чтобы они выдавали корректные результаты, если возникнут трудности попробуй еще раз посмотреть материалы из урока.
У тебя всё получится, жду следующую итерацию!

======================================================================================================

Irina, спасибо за отправку домашней работы!
Ты продемонстрировала понимание темы, твой код выглядит хорошо организованным и читаемым!
Но есть метод, который необходимо исправить:
по п.1 задания = Создай файл со строками вида (x:1,y:5)-(x:2,y:6), описывающими отрезки на плоскости. (в репозитории его нет)
по п.5 задания = Выведи длину в поток вывода. = у тебя выводится сам Segment System.out.println(max.get()); = надо использовать твой метод getLength();

Исправь эти методы чтобы они выдавали корректные результаты, если возникнут трудности попробуй еще раз посмотреть материалы из урока.
У тебя всё получится, жду следующую итерацию!

======================================================================================================

Aleksandr, привет!
Спасибо за отправку домашней работы!
Ты продемонстрировал понимание темы, твой код выглядит хорошо организованным и читаемым!!!
Молодец, что так глубоко погрузился в разбор задания и написал сервис и покрыл его тестами.
Есть несколько некритичных замечаний, которые могут помочь тебе улучшить свой код в будущем:
Например, рекомендую в тесты добавлять аннотацию @DisplayName("название_теста") + message (в случае его непрохождения).
Это необходимо для повышения читаемости кода и его понимания другими программистами - тестов бывает очень много)
Пример ниже
    @DisplayName("Тест функции добавления score")
    @Test
    void addScore() {
        score_1.setScore(5);
        scoreDB.addScore(score_1);
        scoreDB.addScore(score_1);
        Score test = scoreDB.getScore(student_1, ListSubject.Alg);
        Assertions.assertEquals(5, test.getScore(), "Expected score = 5, it came incorrectly");
        Assertions.assertEquals(4, test.getCounter(), "Expected score = 4, it came incorrectly");
    }
Удачи в дальнейшем обучении!

======================================================================================================

Iurii, спасибо за отправку домашней работы!
Ты продемонстрировал понимание темы, твой код выглядит хорошо организованным и читаемым!
Но есть кое-что, что необходимо исправить:
1. метод addStudent - проверь модификатор доступа = если мне потребуется вызвать из метода main какой он должен быть?
2. методе addStudent можно добавить проверку на null для параметров name и score, чтобы избежать ошибки NullPointerException;
3. метод top3() работет некорректно если добавлять меньше 3х студентов (напрмиер 2) получаем NullPointerException. Надо чтобы метод работал корректно с любым кол-вом студентов.
Если возникнут трудности попробуй еще раз посмотреть материалы из урока.
В целом, твоя работа заслуживает похвалы. Продолжай в том же духе!
У тебя всё получится, жду следующую итерацию!

======================================================================================================

Iurii, спасибо за отправку домашней работы!
Молодец, что исправил 3 замечаения = код стал более работоспособен!
Я заметил ещё одну деталь, которую надо изменить:
метод top3() = при добавлении студентов с одинаковым score заменяет их, а не добавляет
например, мы добавим студентов
ResultBoard rb = new ResultBoard();
rb.addStudent("Ivan", 3.0f);
rb.addStudent("Maria", 4.0f);
rb.addStudent("Vlad", 5.0f);
rb.addStudent("Anton", 4.5f);
rb.addStudent("Daria", 1.5f);
rb.addStudent("Vasiliy", 5.0f);
и вызовем метод top3()
System.out.println(rb.top3());
ожидаем что будет вывод [Vlad (у него 5.0f), Vasiliy (у него 5.0f), Anton (у него 4.5f)] или [Vasiliy(у него 5.0f), Vlad(у него 5.0f), Anton(у него 4.5f)]
а получаем : [Vasiliy(у него 5.0f), Anton(у него 4.5f), Maria(у него 4.0f)]
Подумай как это можно исправить - можно попробовать использовать  TreeSet<Student> вместо TreeMap<Float, String> ?
У тебя всё получится, жду следующую итерацию!

======================================================================================================

Irina, спасибо за отправку домашней работы!
Я посмотрел твою работу и поздравляю тебя с тем, что ты успешно справилась с её написанием.
Ты учла все замечания, которые я указывал - молодец!

======================================================================================================

Спасибо за отправку домашней работы, Iurii!
Я оценил твою работу и уверен, что ты хорошо понимаешь тему.
Твой код выглядит читаемым и хорошо организованным.
Однако, я бы хотел отметить два момента, которые нужно исправить.

Во-первых, названия методов должны соответствовать их функционалу. Например, метод readFile() по названию должен считывать файл, а не находить максимальный отрезок.
Поэтому его можно либо разбить на два метода, либо переименовать.

Во-вторых, в методе readFile() нужно закрыть поток BufferedReader после его использования. Это можно сделать с помощью конструкции try-with-resources.

Я хочу похвалить тебя за проделанную работу и уверен, что у тебя все получится в будущем.
Жду с нетерпением следующей итерации!

======================================================================================================

Iurii, спасибо за отправку домашней работы!
Я посмотрел твою работу и поздравляю тебя с тем, что ты успешно справился с её написанием.
Ты учёл все замечания (даже больше - ввёл идентификатор Id), которые я указывал - молодец!

======================================================================================================

Iurii, спасибо за отправку домашней работы!
Я посмотрел твою работу и поздравляю тебя с тем, что ты успешно справился с её написанием.
Ты учёл все замечания, которые я указывал - молодец!

Некритичное замечание - можно использовать только один блок catch для обработки исключений, наследуемых от класса Exception, включая FileNotFoundException и IOException.
Таким образом, вы можете заменить два блока catch на один, который будет перехватывать оба типа исключений.

======================================================================================================

Камила, привет!
Спасибо за отправку домашней работы!
Посмотрел твой код - есть несколько моментов, которые нужно исправить:

1. ты определяешь вначале int i (в цикле for она определяется повторно) =это вызывает ошибку компиляции на твоём скриншоте
    если переменная несет смысл как целое чило из условий задачи, то надо по другому назвать , например
    int n = 20;
    тогда цикл будет
    for (int i = 0; i <= n; i++) {
     ...
     }
2. массив array - ты его создала, но ни разу не используешь
3. в цикле твоё третье условие никогда не будет выполнено т.к. первые два if его опережают
    попробуй цикл с такими условиями:
if (i == 0) { ==> проверка что число n == 0
//...
} else if (i % 3 == 0 && i % 5 == 0) { // ===> fizzbuzz
//...
} else if (i % 3 == 0) { // ===> fizz
//...
 } else if (i % 5 == 0) { //===> buzz
//...
 }

Допиши правильные выводы в условиях цикла.
+ Важно! Обрати внимание на пробелы у тебя указано "fizz buzz" а должно быть "fizzbuzz"

Программирование может быть сложным и иногда требует времени и усилий, чтобы понять его полностью.
Важно продолжать учиться и задавать вопросы, если что-то не понятно!
Я хочу похвалить тебя за проделанную работу и уверен, что у тебя все получится в будущем.
Жду с нетерпением следующей итерации работы!

======================================================================================================

Вадим, спасибо за отправку домашней работы!
Я посмотрел твою работу и поздравляю тебя с тем, что ты успешно справился с её написанием.
Есть несколько некритичных замечаний, которые могут помочь тебе улучшить свой код в будущем:

1. В методе getAverageForSubject переменная avg может быть инициализирована значением 0, поэтому нет необходимости использовать else-блок.
2. В методе lastFiveStudentsWithExcellentMarkOnAnySubject можно заменить ArrayList на LinkedList, так как мы не знаем заранее, сколько элементов будет в списке. LinkedList быстрее добавляет элементы в конец списка и быстрее удаляет элементы из начала списка.
3. Метод containsItem не используется в данной реализации интерфейса Examination, поэтому его можно удалить.
4. В целом, названия переменных и методов соответствуют требованиям Java Code Conventions, но можно добавить комментарии к некоторым методам для лучшего понимания их работы.

Так про тесты, рекомендую в тесты добавлять аннотацию @DisplayName("название_теста") + message (в случае его непрохождения).
Это необходимо для повышения читаемости кода и его понимания другими программистами - тестов бывает очень много)
Пример ниже
    @DisplayName("Тест функции добавления score")
    @Test
    void addScore() {
        score_1.setScore(5);
        scoreDB.addScore(score_1);
        scoreDB.addScore(score_1);
        Score test = scoreDB.getScore(student_1, ListSubject.Alg);
        Assertions.assertEquals(5, test.getScore(), "Expected score = 5, it came incorrectly");
        Assertions.assertEquals(4, test.getCounter(), "Expected score = 4, it came incorrectly");
    }
Удачи в дальнейшем обучении!

======================================================================================================

Эрнест, cпасибо за отправку домашней работы!
Ты продемонстрировал понимание темы, твой код выглядит хорошо организованным и читаемым!!!
Ты отлично справился с заданием!
Отличная работа! Продолжай в том же духе!


======================================================================================================

Iurii, спасибо за отправку домашней работы!

Ты пишешь, что добавил package "practice", для проверки необходимо запускать программу из Main.
Но по ссылке https://github.com/Tayoriko/homework_3_HashMap у тебя такого пакета не обнаружил (возможно ты забыл запушить изменения).
Жду с нетерпением следующей итерации работы!

======================================================================================================

Станислав, спасибо за отправку домашней работы!
Ты продемонстрировал понимание темы, твой код выглядит хорошо организованным и читаемым!
Но есть кое-что, что необходимо исправить:

1. метод addStudent - проверь модификатор доступа = если потребуется вызвать из другого пакета каким он должен быть?

2. методе addStudent можно добавить проверку на null для параметров name и score, чтобы избежать ошибки NullPointerException;

3. метод top3() работет некорректно если добавлять меньше 3х студентов (напрмиер 2) получаем NullPointerException. Надо чтобы метод работал корректно с любым кол-вом студентов.

4. метод top3() = некорректно работает со студентами с одинаковым score
например, мы добавим студентов
ResultBoard rb = new ResultBoard();
rb.addStudent("Ivan", 3.0f);
rb.addStudent("Maria", 4.0f);
rb.addStudent("Vlad", 5.0f);
rb.addStudent("Anton", 4.5f);
rb.addStudent("Daria", 1.5f);
rb.addStudent("Vasiliy", 5.0f);
и вызовем метод top3()
System.out.println(rb.top3());
ожидаем что будет вывод [Vlad (у него 5.0f), Vasiliy (у него 5.0f), Anton (у него 4.5f)] или [Vasiliy(у него 5.0f), Vlad(у него 5.0f), Anton(у него 4.5f)]
а получаем : [Vlad(у него 5.0f), Anton(у него 4.5f), Maria(у него 4.0f)]

Если возникнут трудности попробуй еще раз посмотреть материалы из урока.
В целом, твоя работа заслуживает похвалы. Продолжай в том же духе!
У тебя всё получится, жду следующую итерацию!

======================================================================================================

Aleksey, спасибо за отправку домашней работы!
Ты продемонстрировал понимание темы, твой код выглядит хорошо организованным и читаемым!
Но есть кое-что, что необходимо исправить:
1. надо изенить название переменных для улучшения читаемости кода, например TreeMap<String, Float> treeMap и TreeSet<Student> treeSet надо дать более говорящие называния.
2. метод addStudent - проверь модификатор доступа = если потребуется вызвать из другого пакета каким он должен быть?
3. методе addStudent можно добавить проверку на null для параметров name и score, чтобы избежать ошибки NullPointerException;
4. метод List<Student> top3(float score) = возвращает список из трех студентов, у которых оценка выше или равна заданной в параметре метода, а задание было вывести имена 3-х самых успешных студентов в порядке убывания среднего балла.
Подумай как это можно исправить - можно попробовать использовать  TreeSet<Student> вместо TreeMap<String, Float> ?
+ в методе top3 должно обрабатывать корректно любое кол-во студентов, даже если там 1 студент и 2

Если возникнут трудности попробуй еще раз посмотреть материалы из урока.
В целом, твоя работа заслуживает похвалы. Продолжай в том же духе!
У тебя всё получится, жду следующую итерацию!


======================================================================================================

Iurii, спасибо за отправку домашней работы!

Я посмотрел твою работу и поздравляю тебя с тем, что ты успешно справился с написанием домашней работы.
Твой код хорошо структурирован и понятно написан, что делает его легко читаемым и понятным для других разработчиков.

Однако, у меня есть несколько замечаний, которые могут помочь тебе улучшить свой код в будущем:
1. при выобре меню п4. Read by ID ===>  выводится Please, input ID for delete or 0 for Cancel: 1, хотя ожидаем получение по id а не удаление
2. class OneStudent ===> удалить неиспользуемые импорты
3. Попробуй добавить поддержку кириллицы (добавить символы)
4. В каком методе реализован поиск по 2-м фамилиям? (задание 3, п. 3) - я не обнаружил - прошу уточнить.
В целом, твоя работа заслуживает похвалы - отличная работа! Продолжай в том же духе!

У тебя всё получится, жду следующую итерацию!

======================================================================================================
Aleksey , спасибо за отправку домашней работы!
Я вижу позитивные изменения в коде, но надо кое что ещё исправить.
Сейчас метод top3() = некорректно работает со студентами с одинаковым score
например, мы добавим студентов
ResultBoard rb = new ResultBoard();
rb.addStudent("Ivan", 3.0f);
rb.addStudent("Maria", 4.0f);
rb.addStudent("Vlad", 5.0f);
rb.addStudent("Anton", 4.5f);
rb.addStudent("Daria", 1.5f);
rb.addStudent("Vasiliy", 5.0f);

и вызовем метод top3()

System.out.println(rb.top3());

ожидаем что будет вывод [Vlad (у него 5.0f), Vasiliy (у него 5.0f), Anton (у него 4.5f)] или [Vasiliy(у него 5.0f), Vlad(у него 5.0f), Anton(у него 4.5f)]
а получаем : [Vlad(у него 5.0f), Anton(у него 4.5f), Maria(у него 4.0f)].

Если возникнут трудности попробуй еще раз посмотреть материалы из урока.
В целом, твоя работа заслуживает похвалы. Продолжай в том же духе!
У тебя всё получится, жду следующую итерацию!

======================================================================================================

Привет! На самом деле в методе top3 не так всё сложно как может показаться.
Пришлю тебе пример подобного метода - если возникнут дополнительный вопросы по реализации - пиши

    List<String> top3(int n) throws InvalidInputData {
        if(n < 0) {
          throw   new InvalidInputData("Given a negative number.");
        }
        if(n > set.size()) {
            n = set.size();
        }


        return set.stream()
                .sorted(Comparator.reverseOrder())
                .map(Line::getName)
                .limit(n)
                .collect(Collectors.toList());
    }


или вот без стрима

public List<String> top3(int n) throws InvalidInputData {
        if(n < 0) {
          throw new InvalidInputData("Given a negative number.");
        }
        if(n > set.size()) {
            n = set.size();
        }

        List<Line> sortedLines = new ArrayList<>(set);
        Collections.sort(sortedLines, Collections.reverseOrder());

        List<String> topNames = new ArrayList<>();
        for(int i = 0; i < n; i++) {
            topNames.add(sortedLines.get(i).getName());
        }

        return topNames;


======================================================================================================

Спасибо за отправку домашней работы!
Однако, у меня есть несколько некритичных замечаний, которые могут помочь тебе в будущем:

- Необходимо добавить описание функции в начале файла (например, "Этот файл содержит сценарии функции оформления заказа").
- Следует указать номер сценария перед его описанием (например, "Scenario: 1. Оформление заказа существующего пользователя").
- В сценарии "Оформление заказа с ошибками в форме" можно добавить шаг "And Я вижу поля с ошибками, отмеченные красным цветом".
- В сценариях "Оформление заказа существующего пользователя" и "Оформление заказа нового пользователя" можно добавить шаг "And Я вижу товар в корзине с количеством 1" или аналогичный шаг, чтобы подтвердить, что товар добавлен в корзину.
- Сценарий "Оформление заказа существующего пользователя" можно разбить на несколько более мелких сценариев, чтобы повысить читаемость и понимаемость кода (например, можно выделить сценарий "Добавление товара в корзину").
- Следует добавить примеры для полей формы доставки и оплаты, чтобы понять, какие данные должны быть заполнены.

======================================================================================================

Екатерина, спасибо за отправку домашней работы!

Ты продемонстрировала понимание темы, твой код выглядит хорошо организованным и читаемым!
Но есть кое-что, что необходимо исправить:
1. для ввода данных ты используешь массив = предлагаю использовать просто переменную, например int a;
2. Ты используешь везде println, замени на print т.к. по условию задачи на нужен вывод в строку без переносов
3. Надо разобраться с пробелами чтобы вывод соотетствовал условиям задачи (для 15 0 1 2 fizz 4 buzz fizz 7 8 fizz buzz 11 fizz 13 14 fizzbuzz)
4. Проверь пограничные случаи, если число = 0, вывод должен быть 0 (проверь числа 15, 20, 1 и 0 - какой вывод у них одлжен быть?)

Если возникнут трудности попробуй еще раз посмотреть материалы из урока.
В целом, твоя работа заслуживает похвалы. Продолжай в том же духе!
У тебя всё получится, жду следующую итерацию!

======================================================================================================

Polina, спасибо за отправку домашней работы!
Ты продемонстрировала понимание темы, твой код выглядит хорошо организованным и читаемым!
Прошу тебя прислать архив с твоим кодом или ссылку где я смогу его скачать.
Это необходимо чтобы проверить что программа компилируется и корректно работает (на твоих скриншотах нет запуска программы).
В целом, твоя работа заслуживает похвалы. Продолжай в том же духе!
У тебя всё получится, жду ссылку на программу или архив с программой!


======================================================================================================

Екатерина, спасибо за отправку домашней работы!
Я посмотрел твою работу и поздравляю тебя с тем, что ты успешно справилась с её написанием.
Ты учла все замечания, которые я указывал - молодец!

======================================================================================================

Polina, спасибо за отправку в архиве домашней работы!
Однако, у меня есть несколько замечаний, которые могут помочь тебе улучшить свой код в будущем:

1. В методе getAverageScore необходимо обработать случай, когда список студентов пустой, чтобы избежать деления на ноль.
3. В методе getLastFiveExcellentStudents можно использовать stream API для более компактного кода:
List<String> excellentStudents = students.stream()
    .filter(s -> s.score() == 5)
    .map(Score::name)
    .collect(Collectors.toList());

Отличная работа! Продолжай в том же духе!
У тебя всё получится, жду следующую итерацию!

======================================================================================================

Cпасибо за отправку домашней работы!
Я посмотрел твою работу и поздравляю тебя с тем, что ты успешно справился с её написанием!
Ты учёл все замечания, которые я указывал - молодец!

======================================================================================================

Polina, спасибо за отправку в архиве домашней работы!
Ты продемонстрировала понимание темы, твой код выглядит хорошо организованным и читаемым!
Но есть кое-что, что необходимо исправить:

1. метод addStudent - проверь модификатор доступа = если потребуется вызвать из другого пакета каким он должен быть?

2. методе addStudent можно добавить проверку на null для параметров name и score, чтобы избежать ошибки NullPointerException;

3. метод top3() работает некорректно если добавлять меньше 3х студентов (напрмиер 2) получаем NullPointerException. Надо чтобы метод работал корректно с любым кол-вом студентов.

4. При нескольких вызовах top3() возникает ошибка, потому что в методе top3() ты используешь метод pollFirst() у NavigableSet, который удаляет первый элемент из набора и возвращает его. Если набор пустой, то метод pollFirst() возвращает null.
   В вашем случае, если в NavigableSet меньше трех элементов, то после нескольких вызовов метода pollFirst() он станет пустым, и при следующем вызове метода pollFirst() он вернет null. А затем происходит попытка вызвать метод name у этого null значения, что приводит к ошибке.

5. Убрать лишние выводы System.out.println в методах addStudent (при добавлении) и top3 (на каждой итерации цикла).

Если возникнут трудности попробуй еще раз посмотреть материалы из урока.
В целом, твоя работа заслуживает похвалы. Продолжай в том же духе!
У тебя всё получится, жду следующую итерацию!

======================================================================================================

Aleksandr, cпасибо за отправку домашней работы!
Ты продемонстрировал понимание темы, твой код выглядит хорошо организованным и читаемым!!!
Твои сценарии соответствуют правилам написания хороших BDD тестов BRIEF и могут быть приняты в качестве выполненного задания.
Ты отлично справился с заданием!
Отличная работа! Продолжай в том же духе!

======================================================================================================

Добрый день, Тамара!

Хотел узнать, как прошло мое собеседование и какие результаты были получены.
Я очень заинтересован в этой вакансии и хотел бы получить обратную связь.

Благодарю за ваше время и ожидаю ответа)

======================================================================================================

Привет!

Хочу тебе сказать, что ты молодец! Ты учёл все замечания и даже сделал больше!
Я очень рад, что ты так серьезно отнёсся к этому заданию и продемонстрировал свои знания и навыки.

Но у меня падает часть тестов - прикладываю скриншот.

======================================================================================================

Irina, спасибо за отправку домашней работы!
Есть инструкция для того чтобы настроить сетевое подключение на Mac с Linux, нужно выполнить следующие действия:

1. Откройте терминал в Linux на Mac.
2. Введите команду "sudo nano /etc/network/interfaces" и нажмите Enter.
3. В открывшемся редакторе добавьте следующие строки:

auto eth0
iface eth0 inet dhcp

4. Сохраните изменения, нажав Ctrl+O, затем Enter, и выйдите из редактора, нажав Ctrl+X.
5. Перезагрузите компьютер.

После перезагрузки должно появиться сетевое подключение. Если это не помогло, попробуйте выполнить следующие действия:

1. Откройте терминал в Linux на Mac.
2. Введите команду "sudo nano /etc/NetworkManager/NetworkManager.conf" и нажмите Enter.
3. В открывшемся редакторе найдите строку "managed=false" и замените ее на "managed=true".
4. Сохраните изменения, нажав Ctrl+O, затем Enter, и выйдите из редактора, нажав Ctrl+X.
5. Перезагрузите компьютер.

Если это не помогло, попробуйте установить драйверы для сетевой карты на Mac. Вы можете найти их на сайте производителя вашего Mac.

+++

Сначала попробуй ознакомиться с дополнительными материалами по установке:
Подробная инструкция как установить Linux - https://lifehacker.ru/kak-ustanovit-linux/
Еще одна статья на тему того, как установить данную ОС - https://nastroyvse.ru/opersys/lix/kak-ustanovit-linux.html

======================================================================================================

Отличная работа, Виктория!
Я посмотрел твою работу и поздравляю тебя с тем, что ты успешно справилась с написанием домашней работы!
Твой код хорошо структурирован и понятно написан, что делает его легко читаемым и понятным для других разработчиков.
Твоя домашняя работа была выполнена на высоком уровне!
Я очень рад, что ты так серьезно отнеслась к этому заданию и продемонстрировала свои знания и навыки!
Спасибо за твою работу и удачи в дальнейшем обучении!

======================================================================================================

Аля, cпасибо за отправку домашней работы!
Я изучил твоё решение - ты продемонстрировала понимание темы, твой код выглядит хорошо организованным и читаемым!!!
Все методы написаны правильно, и выдают корректные результаты !
Ты отлично справилась с заданием! Продолжай в том же духе!

======================================================================================================

Игорь , cпасибо за отправку домашней работы!
Я изучил твоё решение - ты продемонстрировал понимание темы, твой код выглядит хорошо организованным и читаемым!!!
Все методы написаны правильно, и выдают корректные результаты !
Ты отлично справился с заданием! Продолжай в том же духе!

======================================================================================================

Татьяна , cпасибо за отправку домашней работы!
Я изучил твоё решение - ты продемонстрировала понимание темы, твой код выглядит хорошо организованным и читаемым!!!
Хочу отменить что ты использовала enum - отлично !!!
Все методы написаны правильно, и выдают корректные результаты !
Ты отлично справился с заданием! Продолжай в том же духе!

======================================================================================================

Данил, cпасибо за отправку домашней работы!
Я изучил твоё решение - ты продемонстрировал понимание темы, твой код выглядит хорошо организованным и читаемым!!!
Хочу отменить что ты пользуешься GitHub - это отлично !!!
Все методы написаны правильно, и выдают корректные результаты !
Ты отлично справился с заданием! Продолжай в том же духе!

Однако, у меня есть несколько замечаний, которые могут помочь тебе улучшить свой код в будущем:
- удаляй закомментированные строки (если они не несут какой то важной информации)
- удаляй неиспользуемый импорты

Это поможет улучшить читаемость и чистоту кода

======================================================================================================

Никита, спасибо за отправку домашней работы!
Я просмотрел оба скриншота - всё выполнено в соответствии с уроком!
Ты продемонстрировал понимание темы и отлично справился с заданием!!
Отличная работа! Продолжай в том же духе!

Также рекомендую дополнительно почитать материалы по установке Linux:
Подробная инструкция как установить Linux - https://lifehacker.ru/kak-ustanovit-linux/


======================================================================================================

Ilnur , спасибо за отправку в архиве домашней работы!
Ты продемонстрировал понимание темы, твой код выглядит хорошо организованным и читаемым!
Код выглядит хорошо, но есть несколько моментов, которые можно улучшить:

1. Удаляй закомментированные строки (если они не несут какой то важной информации) и удаляй неиспользуемый импорты.
Это поможет улучшить читаемость и чистоту кода

2. Для чистоты кода надо изменить  @GetMapping("/max_walks") на принятый в проекте -см. контроллеры выше, т.е. должно быть
@GetMapping("/top_10_walking_users")

3. В методе getTop10WalkingUsers() можно добавить обработку исключений, чтобы вернуть пустой список в случае ошибки.

4. В методе getTop10WalkingUsers() можно использовать ResponseEntity вместо List<String>, чтобы вернуть HTTP-статус и тело ответа.

    @GetMapping("/top_10_walking_users")
    public ResponseEntity<List<Walk>> getTop10WalkingUsers() {
        try {
            List<Walk> walks = repository.getTop10WalkingUsersFromDb();
            return new ResponseEntity<>(walks, HttpStatus.OK);
         catch (Exception e) {
            return new ResponseEntity<>(Collections.emptyList(), HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }

ResponseEntity - это класс из Spring Framework, который представляет собой ответ HTTP-запроса.
Использование ResponseEntity позволяет более гибко управлять форматом и содержимым ответа, а также HTTP-статусом и заголовками.
https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/http/ResponseEntity.html

В целом, твоя работа заслуживает похвалы. Продолжай в том же духе!
У тебя всё получится, жду следующую итерацию!

======================================================================================================