
# Массивы

Массив — это объект специального типа, который может хранить не одно значение, а сразу несколько значений **одного типа**. 
Каждый элемент массива имеет номер (индекс). Массив — это своего рода контейнер, состоящий из нескольких ячеек, 
где каждая ячейка обладает уникальным номером. В каждую ячейку можно положить только одно значение, 
но зато значения могут повторяться в других ячейках.

``` 
String[] potion = new String[5];

potion[0] = "Фиолетовая поганка";
potion[1] = "Огромный кристалл";
potion[2] = "Огненный цветок";
potion[3] = "Голубой гриб";
potion[4] = "Полынь";
```

Квадратные скобки после типа String как раз и являются обозначением массива. Так, после любого типа данных можно 
написать квадратные скобки, и это будет значить, что вы создаете массив. После равно через new создаем массив, 
сразу указывая размер. Указать размер при создании обязательно, иначе ничего не получится. Размер массива 
указывается в квадратных скобках.

## Важные данные

* Индексирование массива всегда начинается с нуля.
* Когда создаете пустой массив примитивных числовых типов (int, double и т.д.), все элементы изначально равны нулю.
* Когда создаете пустой массив строк и других объектов, все элементы изначально равны null.
* Нельзя создать массив без указания его точного размера.
* Изменить величину массива нельзя. Можно только создать новый массив другого размера.


## length

Чтобы узнать длину любого массива, нужно использовать свойство length. Это константное свойство массива, 
для каждого своё. Оно позволяет узнать размер массива, то есть количество ячеек в нем.

``` 
String[] superPotion = new String[111];
// Получим 111
System.out.println(superPotion.length);
```

## Еще один способ инициализации массива

``` 
int[] score = {1, 2, 3, 4, 5};
```

Массив предоставляет разработчику очень мало методов для работы с ним.

Программисты заметили эту проблему и создали класс Arrays, в котором можно найти самые популярные методы для работы 
с массивами. Давайте посмотрим на некоторые полезные методы:

## Arrays.equals — сравнивает 2 массива:

``` 
String[] potion = {"Фиолетовая поганка", "Огромный кристалл", "Огненный цветок"};
String[] anotherPotion = potion.clone();

// Получим true, потому что массивы равны
System.out.println(Arrays.equals(potion, anotherPotion));

// Получим false, потому что мы склонировали массив уже в другом участке памяти
System.out.println(potion.equals(anotherPotion));
```

**Интересный факт: сравнение массивов без использования класса Arrays методом equals сработает совсем иначе, 
потому что сравнение будет происходить по расположению массива в памяти, а не по значениям, содержащимся в ячейках.
Arrays сравнит именно значения внутри, а обычный equals сравнит области памяти, в которых хранятся массивы.**

## Arrays.copyOfRange — копирует массив в указанном диапазоне:
``` 
String[] potion = new String[5];

potion[0] = "Фиолетовая поганка";
potion[1] = "Огромный кристалл";
potion[2] = "Огненный цветок";
potion[3] = "Голубой гриб";
potion[4] = "Полынь";

String[] potionSubset = Arrays.copyOfRange(potion, 1, 4);
```
В этом примере мы создали копию части массива potion с индексами от 1 до 3 включительно, то есть в новый массив 
potionSubset войдут элементы "Огромный кристалл", "Огненный цветок" и "Голубой гриб".

## Arrays.toString — превращает массив в строку:

```
String[] potion = {"Фиолетовая поганка", "Огромный кристалл", "Огненный цветок"};

System.out.println(Arrays.toString(potion));

//Как обычно, здесь подвох
System.out.println(potion.toString());
```
Первый вывод, где используется метод Arrays.toString, будет таким: **[Фиолетовая поганка, Огромный кристалл, Огненный цветок].**

Второй же, где используется обычный toString, будет, например, таким: **java.lang.String;@36baf30c**. 
Снова области памяти в работе, хе-хе.

## Arrays.fill — заполняет массив одинаковыми значениями:
``` 
String[] boxWithFeathers = new String[100];
Arrays.fill(boxWithFeathers, "Feather");
```
Таким образом, массив будет содержать 100 одинаковых строчек. "Feather" в каждой ячейке.

## Arrays.sort — сортирует массив. 
Сортировка элементов зависит от их типа. Стандартно, если мы передадим в метод sort() массив типа int, 
то этот массив будет отсортирован по возрастанию, а если String — по алфавиту:

``` 
String[] potion = {"Фиолетовая поганка", "Огромный кристалл", "Огненный цветок"};
Arrays.sort(potion);
```

Получим **[Огненный цветок, Огромный кристалл, Фиолетовая поганка].**

А еще сортировать можно не только весь массив, но и его часть:
```
Arrays.sort(имяМассива, первыйЭлементВключительно, последнийЭлементНеВключительно);.
```

## Arrays.binarySearch ищет заданное значение в массиве. 
Это не обычный поиск, а бинарный. Он использует особый алгоритм — о нем можете почитать отдельно. 
Благодаря этому поиску в массиве из ста элементов можно найти индекс нужного элемента всего за 6 сравнений. 
Метод возвращает индекс искомого элемента в массиве. Если искомых элементов в массиве несколько, 
просто вернется номер одного из них, важно отметить — любого. Если элемент в массиве не найден, 
вернется отрицательный индекс (-1).

## Ошибки 

Теперь немного про ошибки. Выход за границы массива или некорректная индексация — частая ошибка при работе с массивами. 
Если обратиться к несуществующему индексу массива, получите ошибку IndexOutOfBoundsException.
``` 
int[] array = {4, 8, 15, 16, 23, 42};
// В массиве всего 6 элементов
// Значит содержатся индексы только от 0 до 5, т.е. [0; n - 1]

float incorrectIndex1 = 1.0;
String incorrectIndex2 = "2";
// Нельзя
arr[-1];
arr[6];
arr[incorrectIndex1];
arr[incorrectIndex2];

int correctIndex1 = 3;
long correctIndex2 = 4;
// Можно
arr[0];
arr[5];
arr[correctIndex1];
arr[correctIndex2];
```